[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Noj Documentation",
    "section": "",
    "text": "1 Preface\nNoj (scinojure) is an opinionated way to use the emerging Clojure data stack.\nIt collects a few of the main dependencies together with functions allowing to conveniently use them together.\nSource:\nArtifact:\nStatus: Some parts of the underlying libraries are stable. Some part of Noj are still experimental, and the API will change. These details should be clarified soon.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Noj Documentation",
    "section": "1.1 Getting started",
    "text": "1.1 Getting started\nSee the standalone repo example: Noj - getting started - from raw data to a blog post",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "index.html#existing-chapters-in-this-book",
    "href": "index.html#existing-chapters-in-this-book",
    "title": "Noj Documentation",
    "section": "1.2 Existing chapters in this book:",
    "text": "1.2 Existing chapters in this book:\n\nMachine learning specific functionality in tech.ml.dataset\nMachine learning\nAutoML using metamorph pipelines\nOrdinary least squares with interactions\nDatasets\nPython (experimental üõ†)\nStatistics (experimental üõ†)\nVisualization (experimental üõ†)\nStatistical Visualization (experimental üõ†)\nMore visualization examples (experimental üõ†)\nVisualizing correlation matrices (experimental üõ†) - DRAFT\n\n\nsource: notebooks/index.clj",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "noj_book.prepare_for_ml.html",
    "href": "noj_book.prepare_for_ml.html",
    "title": "2¬† Machine learning specific functionality in tech.ml.dataset",
    "section": "",
    "text": "2.1 Categorical variables\nOne typical problem in machine learning is classification, so learning how to categorize data in different categories. Sometimes data in this format is as well called ‚Äúqualitative data‚Äù or data having discrete values.\nThese categories are often expressed in Clojure as of being of type String or keyword\nIn dataset it is the Column which has specific support for categorical data.\nCreating a column out of categorical data looks like this:\nThis creates a ‚Äúcategorical‚Äù column, which is marked as such in the column metadata.\nPrinting the var shows its ‚Äútype‚Äù as being keyword\nand printing its metadata shows that it got marked as categorical\nThe column is therefore using its metadata to store important information, and it is important to get used to look at it for the case of debugging issues.\nThe same happens, when creating a dataset which is a seq of columns",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Machine learning specific functionality in `tech.ml.dataset`</span>"
    ]
  },
  {
    "objectID": "noj_book.prepare_for_ml.html#categorical-variables",
    "href": "noj_book.prepare_for_ml.html#categorical-variables",
    "title": "2¬† Machine learning specific functionality in tech.ml.dataset",
    "section": "",
    "text": "(require '[tech.v3.dataset.column :as col]\n         '[tech.v3.dataset :as ds])\n\n\n(def column-x (col/new-column  :x  [:a :b]))\n\n\n\n\ncolumn-x\n\n\n#tech.v3.dataset.column&lt;keyword&gt;[2]\n:x\n[:a, :b]\n\n\n\n(meta column-x)\n\n\n{:categorical? true, :name :x, :datatype :keyword, :n-elems 2}\n\n\n\n\n(def categorical-ds\n  (ds/-&gt;dataset\n   {:x [:a :b] :y [\"c\" \"d\"]}))\n\n\ncategorical-ds\n\n\n_unnamed [2 2]:\n\n\n\n:x\n:y\n\n\n\n\n:a\nc\n\n\n:b\nd\n\n\n\n\n\n(map\n meta\n (vals categorical-ds))\n\n\n({:categorical? true, :name :x, :datatype :keyword, :n-elems 2}\n {:categorical? true, :name :y, :datatype :string, :n-elems 2})\n\n\n2.1.1 Transform categorical variables to numerical space\nMost machine learning models can only work on numerical values, both for features and the target variable. So usually we need to transform categorical data into a numeric representation, so each category need to be converted to a number.\nThese numbers have often no meaning for the users, so often we need to convert back into String / keyword space later on.\nNamespace tech.v3.dataset.categorical has several functions to do so.\n\n\n2.1.2 Transform categorical column into a numerical column\n\n(require  '[tech.v3.dataset.categorical :as ds-cat])\n\nThese functions operate on a single column, but expect a dataset and a column name as input.\nWe use them to calculate a mapping from string/keyword to a numerical space (0 ‚Ä¶ x) like this\n\n(ds-cat/fit-categorical-map categorical-ds :x)\n\n\n{:lookup-table {:a 0, :b 1}, :src-column :x, :result-datatype :float64}\n\nThis maps the values in their order of occurrence in the column to 0 .. 1 This is a bit dangerous, as the mapping is decided by ‚Äúrow order‚Äù, which could change or be different on other subset of the data, like test/train splits\nSo it is preferred to be specified explicitly.\n\n(def x-mapping (ds-cat/fit-categorical-map categorical-ds :x [:a :b]))\n\n\nx-mapping\n\n\n{:lookup-table {:a 0, :b 1}, :src-column :x, :result-datatype :float64}\n\nNow we know for sure, that :a is mapped to 0 and :b is mapped to 1. Once we have a mapping, we can use it on new data and transform it into numerical values\n\n(def numerical-categorical-data\n  (ds-cat/transform-categorical-map\n   (ds/-&gt;dataset {:x [:a :b :a :b :b :b]})\n   x-mapping))\n\n\nnumerical-categorical-data\n\n\n_unnamed [6 1]:\n\n\n\n:x\n\n\n\n\n0.0\n\n\n1.0\n\n\n0.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n\n\nWe can revert it as well:\n\n(ds-cat/invert-categorical-map numerical-categorical-data x-mapping)\n\n\n_unnamed [6 1]:\n\n\n\n:x\n\n\n\n\n:a\n\n\n:b\n\n\n:a\n\n\n:b\n\n\n:b\n\n\n:b\n\n\n\n\nWe can as well ask about all mapping of a dataset:\n\n(ds-cat/dataset-&gt;categorical-maps numerical-categorical-data)\n\n\n({:lookup-table {:a 0, :b 1},\n  :src-column :x,\n  :result-datatype :float64})",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Machine learning specific functionality in `tech.ml.dataset`</span>"
    ]
  },
  {
    "objectID": "noj_book.prepare_for_ml.html#convert-several-columns-in-one-go",
    "href": "noj_book.prepare_for_ml.html#convert-several-columns-in-one-go",
    "title": "2¬† Machine learning specific functionality in tech.ml.dataset",
    "section": "2.2 Convert several columns in one go",
    "text": "2.2 Convert several columns in one go\nThe dataset namespace has a convenience function in which several columns can be selected for conversion.\n\n(ds/categorical-&gt;number categorical-ds [:x :y])\n\n\n_unnamed [2 2]:\n\n\n\n:x\n:y\n\n\n\n\n0.0\n1.0\n\n\n1.0\n0.0\n\n\n\n\nThis works as well with filter function from namespace column-filters\n\n(require '[tech.v3.dataset.column-filters :as ds-cf])\n\nto convert all categorical columns, for example:\n\n(ds/categorical-&gt;number categorical-ds ds-cf/categorical)\n\n\n_unnamed [2 2]:\n\n\n\n:x\n:y\n\n\n\n\n0.0\n1.0\n\n\n1.0\n0.0\n\n\n\n\n\n(-&gt;\n (ds/-&gt;dataset {:x [:a :b]\n                :y [:c :d]})\n (ds/categorical-&gt;number [:x :y] [:a :b :c :d]))\n\n\n_unnamed [2 2]:\n\n\n\n:x\n:y\n\n\n\n\n0.0\n2.0\n\n\n1.0\n3.0\n\n\n\n\n\n(-&gt;\n (ds/-&gt;dataset {:x [:a :b]\n                :y [:c :d]})\n (ds/categorical-&gt;number [:x :y] [:a 0 :b 1 :c 2 :d 3]))\n\n\n_unnamed [2 2]:\n\n\n\n:x\n:y\n\n\n\n\n0.0\n4.0\n\n\n2.0\n6.0",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Machine learning specific functionality in `tech.ml.dataset`</span>"
    ]
  },
  {
    "objectID": "noj_book.prepare_for_ml.html#warning-pitfalls-of-categorical-maps",
    "href": "noj_book.prepare_for_ml.html#warning-pitfalls-of-categorical-maps",
    "title": "2¬† Machine learning specific functionality in tech.ml.dataset",
    "section": "2.3 Warning: Pitfalls of Categorical maps",
    "text": "2.3 Warning: Pitfalls of Categorical maps\n\n2.3.1 Automatic mapping might result in surprising results\nWe need to be careful when visually inspecting columns without reverting the categorical maps.\nApplying the following map to a dataset\n\n(ds-cat/fit-categorical-map (ds/-&gt;dataset {:x [\"true\" \"false\" ]}) :x)\n\n\n{:lookup-table {\"true\" 0, \"false\" 1},\n :src-column :x,\n :result-datatype :float64}\n\nwould result in columns in which ‚Äò0‚Äô would mean ‚Äòtrue‚Äô, and ‚Äò1‚Äô would mean ‚Äòfalse‚Äô\n\n\n2.3.2 float vs int\nThe categories can get mapped to int or float\n\n(def ds-with-float-and-int-mappings\n  (-&gt;\n   (ds/-&gt;dataset {:x-float [:a :b]\n                  :x-int [:a :b]})\n   (ds/categorical-&gt;number [:x-float] [] :float64)\n   (ds/categorical-&gt;number [:x-int]   [] :int)))\n\nComparing such columns might not bring the expected result, even though the categorical maps and values look very similar\n\nds-with-float-and-int-mappings\n\n\n_unnamed [2 2]:\n\n\n\n:x-float\n:x-int\n\n\n\n\n0.0\n0\n\n\n1.0\n1\n\n\n\n\n\n(map meta\n     (vals ds-with-float-and-int-mappings))\n\n\n({:categorical? true,\n  :name :x-float,\n  :datatype :float64,\n  :n-elems 2,\n  :categorical-map\n  {:lookup-table {:a 0, :b 1},\n   :src-column :x-float,\n   :result-datatype :float64}}\n {:categorical? true,\n  :name :x-int,\n  :datatype :int,\n  :n-elems 2,\n  :categorical-map\n  {:lookup-table {:a 0, :b 1},\n   :src-column :x-int,\n   :result-datatype :int}})\n\n\n\n2.3.3 Categorical maps attached to a column change semantic value of the Column\nThe existence of categorical maps on a column, change the semantic value of the data. When categorical maps are different for two columns (for whatever reasons), it is not given that the column cell value like 0 means the same in both columns. Columns which have categorical maps should never be compared via clojure.core/= as this will ignore the categorical maps. (unless we are sure that the categorical maps in both are the same) They should be converted back to their original space and then compared. This is specially important for comparing prediction and true value in machine learning for metric calculations.\nSee the following example to illustrate this.\n\n2.3.3.1 Incorrect comparisons\nIn the following the two columns are clearly different (the opposite even)\n\n(def ds-with-different-cat-maps\n  (-&gt;\n   (ds/-&gt;dataset {:x-1 [:a :b :a :b :b :b]\n                  :x-2 [:b :a :b :a :a :a]})\n   (ds/categorical-&gt;number [:x-1 :x-2])))\n\nThe resulting columns look the same, but are not\n\n(:x-1 ds-with-different-cat-maps)\n\n\n#tech.v3.dataset.column&lt;float64&gt;[6]\n:x-1\n[0, 1, 0, 1, 1, 1]\n\n\n(:x-2 ds-with-different-cat-maps)\n\n\n#tech.v3.dataset.column&lt;float64&gt;[6]\n:x-2\n[0, 1, 0, 1, 1, 1]\n\nBy using default categorical-&gt;number we get different categorical maps, having different :lookup-tables\n\n(meta (:x-1 ds-with-different-cat-maps))\n\n\n{:categorical? true,\n :name :x-1,\n :datatype :float64,\n :n-elems 6,\n :categorical-map\n {:lookup-table {:a 0, :b 1},\n  :src-column :x-1,\n  :result-datatype :float64}}\n\n\n(meta (:x-2 ds-with-different-cat-maps))\n\n\n{:categorical? true,\n :name :x-2,\n :datatype :float64,\n :n-elems 6,\n :categorical-map\n {:lookup-table {:b 0, :a 1},\n  :src-column :x-2,\n  :result-datatype :float64}}\n\nso they are (wrongly) compared as equal\n\n(=\n (:x-1 ds-with-different-cat-maps)\n (:x-2 ds-with-different-cat-maps))\n\n\ntrue\n\n\n\n2.3.3.2 Correct comparison\nIn order to compare them correctly, we need to first revert the categorical mappings\n\n(def reverted-ds-with-different-cat-maps\n  (ds-cat/reverse-map-categorical-xforms ds-with-different-cat-maps))\n\n\n(:x-1 reverted-ds-with-different-cat-maps)\n\n\n#tech.v3.dataset.column&lt;keyword&gt;[6]\n:x-1\n[:a, :b, :a, :b, :b, :b]\n\n\n(:x-2 reverted-ds-with-different-cat-maps)\n\n\n#tech.v3.dataset.column&lt;keyword&gt;[6]\n:x-2\n[:b, :a, :b, :a, :a, :a]\n\nand now they compare correctly as :false\n\n(=\n (:x-1 reverted-ds-with-different-cat-maps)\n (:x-2 reverted-ds-with-different-cat-maps))\n\n\nfalse\n\nSo it should be as well avoided to transform mapped columns to other representations, which loose the mappings, like tensor or primitive arrays, or even sequences\n\n\n2.3.3.3 Use the same and fixed mapping\nThis issue can be avoided by specifying concretely the mapping to be used, as being for example {:a 0 :b 1}\n\n(def ds-with-same-cat-maps\n  (-&gt;\n   (ds/-&gt;dataset {:x-1 [:a :b :a :b :b :b]\n                  :x-2 [:b :a :b :a :a :a]})\n   (ds/categorical-&gt;number [:x-1 :x-2] [:a :b])))\n\nmapping spec can be either [:a :b] or [:a 0 :b 1]\n\n(:x-1 ds-with-same-cat-maps)\n\n\n#tech.v3.dataset.column&lt;float64&gt;[6]\n:x-1\n[0, 1, 0, 1, 1, 1]\n\n\n(:x-2 ds-with-same-cat-maps)\n\n\n#tech.v3.dataset.column&lt;float64&gt;[6]\n:x-2\n[1, 0, 1, 0, 0, 0]\n\nwe get same categorical maps\n\n(meta (:x-1 ds-with-same-cat-maps))\n\n\n{:categorical? true,\n :name :x-1,\n :datatype :float64,\n :n-elems 6,\n :categorical-map\n {:lookup-table {:a 0, :b 1},\n  :src-column :x-1,\n  :result-datatype :float64}}\n\n\n(meta (:x-2 ds-with-same-cat-maps))\n\n\n{:categorical? true,\n :name :x-2,\n :datatype :float64,\n :n-elems 6,\n :categorical-map\n {:lookup-table {:a 0, :b 1},\n  :src-column :x-2,\n  :result-datatype :float64}}\n\nso they are correctly compared as not equal\n\n(=\n (:x-1 ds-with-same-cat-maps)\n (:x-2 ds-with-same-cat-maps))\n\n\nfalse\n\nThese 3 pitfalls can be avoided by explicitly specifying the mappings, so using the 4-arity of conversion functions.\n\n(def ds-with-explicit-mapping\n  (-&gt;\n   (ds/-&gt;dataset {:x-1 [:a :b :a :b :b :b]\n                  :x-2 [:b :a :b :a :a :a]})\n   (ds/categorical-&gt;number [:x-1 :x-2] [:a :b] :int)))\n\n\nds-with-explicit-mapping\n\n\n_unnamed [6 2]:\n\n\n\n:x-1\n:x-2\n\n\n\n\n0\n1\n\n\n1\n0\n\n\n0\n1\n\n\n1\n0\n\n\n1\n0\n\n\n1\n0\n\n\n\n\n\n(map meta (vals ds-with-explicit-mapping))\n\n\n({:categorical? true,\n  :name :x-1,\n  :datatype :int,\n  :n-elems 6,\n  :categorical-map\n  {:lookup-table {:a 0, :b 1},\n   :src-column :x-1,\n   :result-datatype :int}}\n {:categorical? true,\n  :name :x-2,\n  :datatype :int,\n  :n-elems 6,\n  :categorical-map\n  {:lookup-table {:a 0, :b 1},\n   :src-column :x-2,\n   :result-datatype :int}})\n\n\n\n\n2.3.4 one-hot-encoding\nFor some models / use cases the categorical data need to be converted in the so called one-hot format. In this every column get multiplied by the number of categories , and then each one-hot column can only have 0 and 1 values.\n\n(def one-hot-map-x (ds-cat/fit-one-hot categorical-ds :x))\n\n\n(def one-hot-map-y (ds-cat/fit-one-hot categorical-ds :y))\n\n\none-hot-map-x\n\n\n{:one-hot-table {:a :x-a, :b :x-b},\n :src-column :x,\n :result-datatype :float64}\n\n\none-hot-map-y\n\n\n{:one-hot-table {\"d\" :y-d, \"c\" :y-c},\n :src-column :y,\n :result-datatype :float64}\n\n\ncategorical-ds\n\n\n_unnamed [2 2]:\n\n\n\n:x\n:y\n\n\n\n\n:a\nc\n\n\n:b\nd\n\n\n\n\nget transformed by\n\n(def one-hot-ds\n  (-&gt; categorical-ds\n      (ds-cat/transform-one-hot one-hot-map-x)\n      (ds-cat/transform-one-hot one-hot-map-y)))\n\ninto\n\none-hot-ds\n\n\n_unnamed [2 4]:\n\n\n\n:x-a\n:x-b\n:y-d\n:y-c\n\n\n\n\n1\n0\n0\n1\n\n\n0\n1\n1\n0\n\n\n\n\nThere are similar functions to convert this format back.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Machine learning specific functionality in `tech.ml.dataset`</span>"
    ]
  },
  {
    "objectID": "noj_book.prepare_for_ml.html#features-and-inference-target-in-a-dataset",
    "href": "noj_book.prepare_for_ml.html#features-and-inference-target-in-a-dataset",
    "title": "2¬† Machine learning specific functionality in tech.ml.dataset",
    "section": "2.4 Features and inference target in a dataset",
    "text": "2.4 Features and inference target in a dataset\nA dataset for supervised machine learning has always two groups of columns. They can either be the features or the inference targets. The goal of the learning is to find the relationship between the two groups and therefore be able to predict inference targets from features. Sometimes the features are called X and the targets y.\nWhen constructing a dataset\n\n(def ds\n  (ds/-&gt;dataset {:x-1 [0 1 0]\n                 :x-2 [1 0 1]\n                 :y [:a :a :b]}))\n\nwe need to mark explicitly which columns are features and which are targets in order to be able to use the dataset later for machine learning in metamorph.ml\nAs normally only one or a few columns are inference targets, we can simply mark those and the other columns are regarded as features.\n\n(require  '[tech.v3.dataset.modelling :as ds-mod])\n\n\n(def modelled-ds\n  (-&gt; ds\n      (ds-mod/set-inference-target :y)))\n\n(works as well with a seq)\nThis is marked as well in the column metadata.\n\n(-&gt; modelled-ds :y meta)\n\n\n{:categorical? true,\n :name :y,\n :datatype :keyword,\n :n-elems 3,\n :inference-target? true}\n\nThere are several functions to get information on features and inference targets:\n\n(ds-mod/feature-ecount modelled-ds)\n\n\n3\n\n\n(ds-cf/feature modelled-ds)\n\n\n_unnamed [3 2]:\n\n\n\n:x-1\n:x-2\n\n\n\n\n0\n1\n\n\n1\n0\n\n\n0\n1\n\n\n\n\n\n(ds-cf/target modelled-ds)\n\n\n_unnamed [3 1]:\n\n\n\n:y\n\n\n\n\n:a\n\n\n:a\n\n\n:b",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Machine learning specific functionality in `tech.ml.dataset`</span>"
    ]
  },
  {
    "objectID": "noj_book.prepare_for_ml.html#combining-categorical-transformation-and-modelling",
    "href": "noj_book.prepare_for_ml.html#combining-categorical-transformation-and-modelling",
    "title": "2¬† Machine learning specific functionality in tech.ml.dataset",
    "section": "2.5 Combining categorical transformation and modelling",
    "text": "2.5 Combining categorical transformation and modelling\nVery often we need to do transform and model for doing classification and combine the -&gt;numeric transformation of categorical vars and the marking of inference targets.\n\n(def ds-ready-for-train\n  (-&gt;\n   {:x-1 [0 1 0]\n    :x-2 [1 0 1]\n    :cat  [:a :b :c]\n    :y [:a :a :b]}\n\n   (ds/-&gt;dataset)\n   (ds/categorical-&gt;number [:y])\n   (ds/categorical-&gt;one-hot [:cat])\n   (ds-mod/set-inference-target [:y])))\n\n\nds-ready-for-train\n\n\n_unnamed [3 6]:\n\n\n\n:x-1\n:x-2\n:y\n:cat-c\n:cat-a\n:cat-b\n\n\n\n\n0\n1\n0.0\n0\n1\n0\n\n\n1\n0\n0.0\n0\n0\n1\n\n\n0\n1\n1.0\n1\n0\n0\n\n\n\n\nSuch a dataset is ready for training as it only contains numerical variables which have the categorical maps in place for easy converting back, if needed. The inference target is marked as well, as we can see in the meta data:\n\n(map meta (vals ds-ready-for-train))\n\n\n({:name :x-1, :datatype :int64, :n-elems 3}\n {:name :x-2, :datatype :int64, :n-elems 3}\n {:categorical? true,\n  :name :y,\n  :datatype :float64,\n  :n-elems 3,\n  :categorical-map\n  {:lookup-table {:a 0, :b 1},\n   :src-column :y,\n   :result-datatype :float64},\n  :inference-target? true}\n {:categorical? true,\n  :name :cat-c,\n  :datatype :int8,\n  :n-elems 3,\n  :one-hot-map\n  {:one-hot-table {:c :cat-c, :a :cat-a, :b :cat-b},\n   :src-column :cat,\n   :result-datatype :float64}}\n {:categorical? true,\n  :name :cat-a,\n  :datatype :int8,\n  :n-elems 3,\n  :one-hot-map\n  {:one-hot-table {:c :cat-c, :a :cat-a, :b :cat-b},\n   :src-column :cat,\n   :result-datatype :float64}}\n {:categorical? true,\n  :name :cat-b,\n  :datatype :int8,\n  :n-elems 3,\n  :one-hot-map\n  {:one-hot-table {:c :cat-c, :a :cat-a, :b :cat-b},\n   :src-column :cat,\n   :result-datatype :float64}})\n\nMost models in the metamorph.ml ecosystem can work with data in this format.\nSide remark: If needed, data could as well be easily transformed into a tensor. Most models do this internally anyway (often to primitive arrays)\n\n(require 'tech.v3.dataset.tensor)\n\n\n(def ds-tensor\n  (tech.v3.dataset.tensor/dataset-&gt;tensor ds-ready-for-train))\n\n\nds-tensor\n\n\n#tech.v3.tensor&lt;float64&gt;[3 6]\n[[0.000 1.000 0.000 0.000 1.000 0.000]\n [1.000 0.000 0.000 0.000 0.000 1.000]\n [0.000 1.000 1.000 1.000 0.000 0.000]]\n\nor we can do so, if needed, but this looses the notation of features / inference target\n\n(tech.v3.tensor/-&gt;jvm ds-tensor)\n\n\n[[0.0 1.0 0.0 0.0 1.0 0.0]\n [1.0 0.0 0.0 0.0 0.0 1.0]\n [0.0 1.0 1.0 1.0 0.0 0.0]]\n\n\nsource: notebooks/noj_book/prepare_for_ml.clj",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Machine learning specific functionality in `tech.ml.dataset`</span>"
    ]
  },
  {
    "objectID": "noj_book.ml_basic.html",
    "href": "noj_book.ml_basic.html",
    "title": "3¬† Machine learning",
    "section": "",
    "text": "3.1 Inspect data\nThe titanic data is part of metamorph.ml and in the form of a train, test split\nWe use the :train part only for this tutorial.\nthis is the full dataset\nIt has various columns\nof which we can get some statistics\nThe data is more or less balanced across the 2 classes:\nWe will make a very simple model, which will predict the column :survived from columns :sex , :pclass and :embark These represent the ‚Äúgender‚Äù, ‚Äúpassenger class‚Äù and ‚Äúport of embarkment‚Äù",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Machine learning</span>"
    ]
  },
  {
    "objectID": "noj_book.ml_basic.html#inspect-data",
    "href": "noj_book.ml_basic.html#inspect-data",
    "title": "3¬† Machine learning",
    "section": "",
    "text": "(-&gt;\n (data/titanic-ds-split)\n :train)\n\n\n_unnamed [891 12]:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n:passenger-id\n:survived\n:pclass\n:name\n:sex\n:age\n:sib-sp\n:parch\n:ticket\n:fare\n:cabin\n:embarked\n\n\n\n\n1\n0\n3\nBraund, Mr.¬†Owen Harris\nmale\n22.0\n1\n0\nA/5 21171\n7.2500\n\nS\n\n\n2\n1\n1\nCumings, Mrs.¬†John Bradley (Florence Briggs Thayer)\nfemale\n38.0\n1\n0\nPC 17599\n71.2833\nC85\nC\n\n\n3\n1\n3\nHeikkinen, Miss. Laina\nfemale\n26.0\n0\n0\nSTON/O2. 3101282\n7.9250\n\nS\n\n\n4\n1\n1\nFutrelle, Mrs.¬†Jacques Heath (Lily May Peel)\nfemale\n35.0\n1\n0\n113803\n53.1000\nC123\nS\n\n\n5\n0\n3\nAllen, Mr.¬†William Henry\nmale\n35.0\n0\n0\n373450\n8.0500\n\nS\n\n\n6\n0\n3\nMoran, Mr.¬†James\nmale\n\n0\n0\n330877\n8.4583\n\nQ\n\n\n7\n0\n1\nMcCarthy, Mr.¬†Timothy J\nmale\n54.0\n0\n0\n17463\n51.8625\nE46\nS\n\n\n8\n0\n3\nPalsson, Master. Gosta Leonard\nmale\n2.0\n3\n1\n349909\n21.0750\n\nS\n\n\n9\n1\n3\nJohnson, Mrs.¬†Oscar W (Elisabeth Vilhelmina Berg)\nfemale\n27.0\n0\n2\n347742\n11.1333\n\nS\n\n\n10\n1\n2\nNasser, Mrs.¬†Nicholas (Adele Achem)\nfemale\n14.0\n1\n0\n237736\n30.0708\n\nC\n\n\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n\n\n881\n1\n2\nShelley, Mrs.¬†William (Imanita Parrish Hall)\nfemale\n25.0\n0\n1\n230433\n26.0000\n\nS\n\n\n882\n0\n3\nMarkun, Mr.¬†Johann\nmale\n33.0\n0\n0\n349257\n7.8958\n\nS\n\n\n883\n0\n3\nDahlberg, Miss. Gerda Ulrika\nfemale\n22.0\n0\n0\n7552\n10.5167\n\nS\n\n\n884\n0\n2\nBanfield, Mr.¬†Frederick James\nmale\n28.0\n0\n0\nC.A./SOTON 34068\n10.5000\n\nS\n\n\n885\n0\n3\nSutehall, Mr.¬†Henry Jr\nmale\n25.0\n0\n0\nSOTON/OQ 392076\n7.0500\n\nS\n\n\n886\n0\n3\nRice, Mrs.¬†William (Margaret Norton)\nfemale\n39.0\n0\n5\n382652\n29.1250\n\nQ\n\n\n887\n0\n2\nMontvila, Rev.¬†Juozas\nmale\n27.0\n0\n0\n211536\n13.0000\n\nS\n\n\n888\n1\n1\nGraham, Miss. Margaret Edith\nfemale\n19.0\n0\n0\n112053\n30.0000\nB42\nS\n\n\n889\n0\n3\nJohnston, Miss. Catherine Helen ‚ÄúCarrie‚Äù\nfemale\n\n1\n2\nW./C. 6607\n23.4500\n\nS\n\n\n890\n1\n1\nBehr, Mr.¬†Karl Howell\nmale\n26.0\n0\n0\n111369\n30.0000\nC148\nC\n\n\n891\n0\n3\nDooley, Mr.¬†Patrick\nmale\n32.0\n0\n0\n370376\n7.7500\n\nQ\n\n\n\n\n\n(defonce titanic-split\n  (data/titanic-ds-split))\n\n\n\n(def titanic\n  (-&gt; titanic-split\n      :train\n      (tc/add-column :survived\n                         (fn [ds]\n                           (map\n                            (fn [el] (case el\n                                        0 \"no\"\n                                        1 \"yes\"))\n                            (:survived ds))))))\n\n\n\n(tc/column-names titanic)\n\n\n(:passenger-id\n :survived\n :pclass\n :name\n :sex\n :age\n :sib-sp\n :parch\n :ticket\n :fare\n :cabin\n :embarked)\n\n\n\n(ds/descriptive-stats titanic)\n\n\n_unnamed: descriptive-stats [12 12]:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n:col-name\n:datatype\n:n-valid\n:n-missing\n:min\n:mean\n:mode\n:max\n:standard-deviation\n:skew\n:first\n:last\n\n\n\n\n:passenger-id\n:int16\n891\n0\n1.00\n446.00000000\n\n891.0000\n257.35384202\n0.00000000\n1\n891\n\n\n:survived\n:string\n891\n0\n\n\nno\n\n\n\nno\nno\n\n\n:pclass\n:int16\n891\n0\n1.00\n2.30864198\n\n3.0000\n0.83607124\n-0.63054791\n3\n3\n\n\n:name\n:string\n891\n0\n\n\nMallet, Mr.¬†Albert\n\n\n\nBraund, Mr.¬†Owen Harris\nDooley, Mr.¬†Patrick\n\n\n:sex\n:string\n891\n0\n\n\nmale\n\n\n\nmale\nmale\n\n\n:age\n:float64\n714\n177\n0.42\n29.69911765\n\n80.0000\n14.52649733\n0.38910778\n22.00\n32.00\n\n\n:sib-sp\n:int16\n891\n0\n0.00\n0.52300786\n\n8.0000\n1.10274343\n3.69535173\n1\n0\n\n\n:parch\n:int16\n891\n0\n0.00\n0.38159371\n\n6.0000\n0.80605722\n2.74911705\n0\n0\n\n\n:ticket\n:string\n891\n0\n\n\nCA. 2343\n\n\n\nA/5 21171\n370376\n\n\n:fare\n:float64\n891\n0\n0.00\n32.20420797\n\n512.3292\n49.69342860\n4.78731652\n7.250\n7.750\n\n\n:cabin\n:string\n204\n687\n\n\n\n\n\n\n\n\n\n\n:embarked\n:string\n889\n2\n\n\nS\n\n\n\nS\nQ\n\n\n\n\n\n\n(-&gt; titanic :survived frequencies)\n\n\n{\"no\" 549, \"yes\" 342}\n\n\n\n(def categorical-feature-columns [:sex :pclass :embarked])\n\n\n(def target-column :survived)",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Machine learning</span>"
    ]
  },
  {
    "objectID": "noj_book.ml_basic.html#convert-categorical-features-to-numeric",
    "href": "noj_book.ml_basic.html#convert-categorical-features-to-numeric",
    "title": "3¬† Machine learning",
    "section": "3.2 Convert categorical features to numeric",
    "text": "3.2 Convert categorical features to numeric\nAs we need to convert the non numerical feature columns to categorical, we will first look at their unique values:\n\n(map\n #(hash-map\n   :col-name %\n   :values  (distinct (get titanic %)))\n categorical-feature-columns)\n\n\n({:col-name :sex, :values (\"male\" \"female\")}\n {:col-name :pclass, :values (3 1 2)}\n {:col-name :embarked, :values (\"S\" \"C\" \"Q\" nil)})\n\nThis allows us now to set specifically the values in the conversion to numbers. This is a good practice, instead of the relying on the automatic selection of the categorical mapping:\n\n(require\n         '[tech.v3.dataset.categorical :as ds-cat]\n         '[tech.v3.dataset.modelling :as ds-mod]\n         '[tech.v3.dataset.column-filters :as cf])\n\nThis gives then the selected and numeric columns like this:\n\n(def relevant-titanic-data\n  (-&gt; titanic\n      (tc/select-columns (conj categorical-feature-columns target-column))\n      (ds/drop-missing)\n      (ds/categorical-&gt;number [:survived] [\"no\" \"yes\"] :float64)\n      (ds-mod/set-inference-target target-column)))\n\nof which we can inspect the lookup-tables\n\n(def cat-maps\n  [(ds-cat/fit-categorical-map relevant-titanic-data :sex [\"male\" \"female\"] :float64)\n   (ds-cat/fit-categorical-map relevant-titanic-data :pclass [0 1 2] :float64)\n   (ds-cat/fit-categorical-map relevant-titanic-data :embarked [\"S\" \"Q\" \"C\"] :float64)])\n\n\ncat-maps\n\n\n[{:lookup-table {\"male\" 0, \"female\" 1},\n  :src-column :sex,\n  :result-datatype :float64}\n {:lookup-table {0 0, 1 1, 2 2, 3 3},\n  :src-column :pclass,\n  :result-datatype :float64}\n {:lookup-table {\"S\" 0, \"Q\" 1, \"C\" 2},\n  :src-column :embarked,\n  :result-datatype :float64}]\n\nAfter the mappings are applied, we have a numeric dataset, as expected by most models.\n\n(def numeric-titanic-data\n  (reduce (fn [ds cat-map]\n            (ds-cat/transform-categorical-map ds cat-map))\n          relevant-titanic-data\n          cat-maps))\n\n\n(tc/head\n numeric-titanic-data)\n\n\n_unnamed [5 4]:\n\n\n\n:sex\n:pclass\n:embarked\n:survived\n\n\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n1.0\n1.0\n2.0\n1.0\n\n\n1.0\n3.0\n0.0\n1.0\n\n\n1.0\n1.0\n0.0\n1.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n\n\nSplit data into train and test set Now we split the data into train and test. By we use a :holdout strategy, so will get a single split in training an test data.\n\n(def split\n  (first\n   (tc/split-&gt;seq numeric-titanic-data :holdout {:seed 112723})))\n\n\nsplit\n\n\n{\n\n\n\n\n\n\n\n\n:train\n\n\n\nGroup: 0 [592 4]:\n\n\n\n:sex\n:pclass\n:embarked\n:survived\n\n\n\n\n0.0\n3.0\n2.0\n0.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n1.0\n3.0\n2.0\n1.0\n\n\n0.0\n1.0\n0.0\n0.0\n\n\n1.0\n3.0\n0.0\n0.0\n\n\n1.0\n2.0\n0.0\n1.0\n\n\n1.0\n3.0\n0.0\n0.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n1.0\n1.0\n2.0\n1.0\n\n\n...\n...\n...\n...\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n1.0\n2.0\n0.0\n1.0\n\n\n0.0\n3.0\n2.0\n1.0\n\n\n1.0\n2.0\n0.0\n0.0\n\n\n0.0\n2.0\n0.0\n0.0\n\n\n1.0\n3.0\n0.0\n1.0\n\n\n0.0\n2.0\n0.0\n0.0\n\n\n1.0\n2.0\n0.0\n1.0\n\n\n0.0\n3.0\n0.0\n1.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n3.0\n1.0\n0.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n:test\n\n\n\nGroup: 0 [297 4]:\n\n\n\n:sex\n:pclass\n:embarked\n:survived\n\n\n\n\n0.0\n1.0\n0.0\n0.0\n\n\n1.0\n3.0\n0.0\n0.0\n\n\n0.0\n2.0\n0.0\n0.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n3.0\n0.0\n1.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n1.0\n3.0\n2.0\n1.0\n\n\n0.0\n1.0\n2.0\n0.0\n\n\n...\n...\n...\n...\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n1.0\n3.0\n0.0\n0.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n1.0\n3.0\n1.0\n1.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n1.0\n2.0\n2.0\n1.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n3.0\n0.0\n1.0\n\n\n0.0\n1.0\n0.0\n0.0\n\n\n1.0\n1.0\n2.0\n1.0\n\n\n\n\n\n\n\n\n}",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Machine learning</span>"
    ]
  },
  {
    "objectID": "noj_book.ml_basic.html#train-a-model",
    "href": "noj_book.ml_basic.html#train-a-model",
    "title": "3¬† Machine learning",
    "section": "3.3 Train a model",
    "text": "3.3 Train a model\nNow its time to train a model.\n\n(require '[scicloj.metamorph.ml :as ml]\n         '[scicloj.metamorph.ml.classification]\n         '[scicloj.metamorph.ml.loss :as loss])\n\n\n3.3.1 Dummy model\nWe start with a dummy model, which simply predicts the majority class\n\n(def dummy-model (ml/train (:train split) {:model-type :metamorph.ml/dummy-classifier}))\n\n\n(def dummy-prediction\n  (ml/predict (:test split) dummy-model))\n\nIt always predicts a single class, as expected:\n\n(-&gt; dummy-prediction :survived frequencies)\n\n\n{1.0 297}\n\nwe can calculate accuracy by using a metric after having converted the numerical data back to original (important !) We should never compare mapped columns directly.\n\n(loss/classification-accuracy\n (:survived (ds-cat/reverse-map-categorical-xforms (:test split)))\n (:survived (ds-cat/reverse-map-categorical-xforms dummy-prediction)))\n\n\n0.3973063973063973\n\nIt‚Äôs performance is poor, even worse the coin flip.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Machine learning</span>"
    ]
  },
  {
    "objectID": "noj_book.ml_basic.html#logistic-regression",
    "href": "noj_book.ml_basic.html#logistic-regression",
    "title": "3¬† Machine learning",
    "section": "3.4 Logistic regression",
    "text": "3.4 Logistic regression\nNext model to use is Logistic Regression\n\n(require '[scicloj.ml.smile.classification])\n\n\n(def lreg-model (ml/train (:train split) {:model-type :smile.classification/logistic-regression}))\n\n\n(def lreg-prediction\n  (ml/predict (:test split) lreg-model))\n\n\n(loss/classification-accuracy\n (:survived (ds-cat/reverse-map-categorical-xforms (:test split)))\n (:survived (ds-cat/reverse-map-categorical-xforms lreg-prediction)))\n\n\n0.7373737373737373\n\nIts performance is better, 60 %",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Machine learning</span>"
    ]
  },
  {
    "objectID": "noj_book.ml_basic.html#random-forrest",
    "href": "noj_book.ml_basic.html#random-forrest",
    "title": "3¬† Machine learning",
    "section": "3.5 Random forrest",
    "text": "3.5 Random forrest\nNext is random forrest\n\n(def rf-model (ml/train (:train split) {:model-type :smile.classification/random-forest}))\n\n\n(def rf-prediction\n  (ml/predict (:test split) rf-model))\n\n\n(loss/classification-accuracy\n (:survived (ds-cat/reverse-map-categorical-xforms (:test split)))\n (:survived (ds-cat/reverse-map-categorical-xforms rf-prediction)))\n\n\n0.7676767676767677\n\nbest so far, 71 %\nFrom the logistic regression model we can get via java Interop some model explanations, for example the variable importance.\n\n(-&gt;&gt;\n (map\n  (fn [predictor importance]\n    (hash-map :predictor (-&gt; predictor str csk/-&gt;kebab-case-keyword)\n              :importance importance))\n\n  (-&gt; rf-model ml/thaw-model .formula .predictors)\n  (-&gt; rf-model ml/thaw-model .importance))\n (sort-by :importance)\n reverse)\n\n\n({:predictor :sex, :importance 46.78962303978025}\n {:predictor :pclass, :importance 10.161034312486382}\n {:predictor :embarked, :importance 1.9200954892919857})\n\nwe can see that :sex is more important to predict :survived then :pclass and :embark",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Machine learning</span>"
    ]
  },
  {
    "objectID": "noj_book.automl.html",
    "href": "noj_book.automl.html",
    "title": "4¬† AutoML using metamorph pipelines",
    "section": "",
    "text": "4.1 The metamorph pipeline abstraction\nFor doing automl, it is very useful to be able to handle the steps of machine learning pipeline (so data transformations and modeling) as a single function which can be moved around freely. This cannot work with a threading macro, as this executes immediate.\nThe Clojure way to do this, is function composing and higher level functions\n(The following is a very low level explanation of metamorph, as a metamorph.ml user we do not use this low-level functions , see next chapter)\nWhile before we saw how to use the pair of train and predict to perform machine learning, AutoML requires us to use an other abstraction, in order to encapsulate both train and predict in single function.(or other any operation)\nWe will use the concept of a ‚Äúmetamorph pipeline‚Äù, which is a sequence of specific functions, and each function can behaves differently, depending on the ‚Äúmode‚Äù in which the pipelines get run. It can run either in mode :fit or in mode :transform, and the functions of the pipeline can (but don‚Äôt need to) do different things depend on the mode\nSpecifically we have a function called metamorph.ml/model which will do train in mode :fit and predict in mode :transform\nThe names :fit and :transform come from the fact that functions could do other things then train and predict, so :fit and :transform represent a more general concept then train/predict\nWe will use the ready-for-modeling data from basic-ml tutorial,\nso lets create splits of the data first.\nIn its foundation a metamorph pipeline is a sequential composition of functions, which all take a map as only parameter, the so called context, and they return an other context, changed by the functions. The composed function , hence the pipeline overall, has this same property. Any other function parameters are closed over on function creation. The following creates such a composed function out of other metamorph compliant operations. The overall result of the pipeline function, is the result of the last operation. (in this case we have only ‚Äò1‚Äô operation)\nIn nearly all cases, the last pipeline operation is ml/model . But this is not absolutely required.\nas we see, this is a function itself\nThis function is metamorph compliant, so it takes a map (my-pipeline {}) and returns a map.\nBut this map cannot be ‚Äúarbitrary‚Äù, it need to adhere to the metamorph conventions.\nThe following trains a model, because the ml/model function does this when called with :mode :fit And it is the only operation in the pipeline, so the pipeline does one thing, it trains a model\nThis context map has the ‚Äúdata‚Äù, the ‚Äúmode‚Äù and an UUID for each operation (we had only one in this pipeline)\nThe model function has closed over the id, so is knows ‚Äúhis id‚Äù, so in the transform mode it can get the data created at :fit. So the model function can ‚Äúsend‚Äù data to itself from :fit to :transform, the trained model.\nSo this will do the predict on new data\nFor the dummy-model we do not see a trained-model, but it ‚Äúcommunicates‚Äù the majority class from the train data to use it for prediction. So the dummy-model has ‚Äòlearned‚Äô the majority class from its training data.\nSo we can get prediction result out of the ctx:\nThis works as long as all operations of the pipeline follow the metamorph convention (we can create such compliant functions, out of normal dataset-&gt;dataset functions, as we will see)\nmy-pipeline represents therefore a not yet executed model training / prediction. It can be freely moved around and applied to a dataset when needed.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>AutoML using metamorph pipelines</span>"
    ]
  },
  {
    "objectID": "noj_book.automl.html#the-metamorph-pipeline-abstraction",
    "href": "noj_book.automl.html#the-metamorph-pipeline-abstraction",
    "title": "4¬† AutoML using metamorph pipelines",
    "section": "",
    "text": "(require '[scicloj.metamorph.ml :as ml]\n         '[scicloj.metamorph.core :as mm]\n         '[tablecloth.api :as tc])\n\n\n\n(def titanic ml-basic/numeric-titanic-data)\n\n\n\n(def splits (first (tc/split-&gt;seq titanic)))\n\n\n(def train-ds (:train splits))\n\n\n(def test-ds (:test splits))\n\n\n\n\n(def my-pipeline\n  (mm/pipeline\n   (ml/model {:model-type :metamorph.ml/dummy-classifier})))\n\n\n\nmy-pipeline\n\n\n#function[clojure.core/partial/fn--5908]\n\n\n\n\n\n(def ctx-after-train\n  (my-pipeline {:metamorph/data train-ds\n                :metamorph/mode :fit}))\n\n\nctx-after-train\n\n\n{\n\n\n\n\n\n\n\n\n:metamorph/data\n\n\n\nGroup: 0 [711 4]:\n\n\n\n:sex\n:pclass\n:embarked\n:survived\n\n\n\n\n1.0\n3.0\n2.0\n0.0\n\n\n0.0\n3.0\n2.0\n0.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n1.0\n0.0\n0.0\n\n\n0.0\n3.0\n1.0\n0.0\n\n\n0.0\n1.0\n2.0\n0.0\n\n\n0.0\n1.0\n0.0\n1.0\n\n\n0.0\n3.0\n0.0\n1.0\n\n\n1.0\n3.0\n0.0\n1.0\n\n\n...\n...\n...\n...\n\n\n0.0\n2.0\n2.0\n0.0\n\n\n1.0\n3.0\n1.0\n0.0\n\n\n1.0\n1.0\n2.0\n1.0\n\n\n0.0\n3.0\n0.0\n1.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n3.0\n1.0\n0.0\n\n\n1.0\n1.0\n2.0\n1.0\n\n\n0.0\n3.0\n1.0\n0.0\n\n\n1.0\n2.0\n0.0\n1.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n1.0\n0.0\n0.0\n\n\n\n\n\n\n\n\n:metamorph/mode :fit#uuid \"57414195-1514-43bc-bc05-f666364924a9\" {:model-data {:majority-class 1.0, :distinct-labels (0.0 1.0)}, :options {:model-type :metamorph.ml/dummy-classifier}, :id #uuid \"90771c94-150a-4d39-ae15-3eb88d9fb897\", :feature-columns [:sex :pclass :embarked], :target-columns [:survived], :target-categorical-maps {:survived #tech.v3.dataset.categorical.CategoricalMap{:lookup-table {\"no\" 0, \"yes\" 1}, :src-column :survived, :result-datatype :float64}}, :scicloj.metamorph.ml/unsupervised? nil}}\n\n\n(keys ctx-after-train)\n\n\n(:metamorph/data\n :metamorph/mode\n #uuid \"57414195-1514-43bc-bc05-f666364924a9\")\n\n\n\n(vals ctx-after-train)\n\n\n(Group: 0 [711 4]:\n\n\n\n:sex\n:pclass\n:embarked\n:survived\n\n\n\n\n1.0\n3.0\n2.0\n0.0\n\n\n0.0\n3.0\n2.0\n0.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n1.0\n0.0\n0.0\n\n\n0.0\n3.0\n1.0\n0.0\n\n\n0.0\n1.0\n2.0\n0.0\n\n\n0.0\n1.0\n0.0\n1.0\n\n\n0.0\n3.0\n0.0\n1.0\n\n\n1.0\n3.0\n0.0\n1.0\n\n\n...\n...\n...\n...\n\n\n0.0\n2.0\n2.0\n0.0\n\n\n1.0\n3.0\n1.0\n0.0\n\n\n1.0\n1.0\n2.0\n1.0\n\n\n0.0\n3.0\n0.0\n1.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n3.0\n1.0\n0.0\n\n\n1.0\n1.0\n2.0\n1.0\n\n\n0.0\n3.0\n1.0\n0.0\n\n\n1.0\n2.0\n0.0\n1.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n1.0\n0.0\n0.0\n\n\n\n:fit\n{:model-data {:majority-class 1.0, :distinct-labels (0.0 1.0)},\n :options {:model-type :metamorph.ml/dummy-classifier},\n :id #uuid \"90771c94-150a-4d39-ae15-3eb88d9fb897\",\n :feature-columns [:sex :pclass :embarked],\n :target-columns [:survived],\n :target-categorical-maps\n {:survived\n  {:lookup-table {\"no\" 0, \"yes\" 1},\n   :src-column :survived,\n   :result-datatype :float64}},\n :scicloj.metamorph.ml/unsupervised? nil}\n)\n\n\n\n\n(def ctx-after-predict\n  (my-pipeline (assoc ctx-after-train\n                      :metamorph/mode :transform\n                      :metamorph/data test-ds)))\n\n\nctx-after-predict\n\n\n{\n\n\n\n\n\n\n\n\n:metamorph/data\n\n\n\n_unnamed [178 1]:\n\n\n\n:survived\n\n\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n...\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n\n\n\n\n\n\n:metamorph/mode :transform\n\n\n\n\n\n\n\n\n#uuid \"57414195-1514-43bc-bc05-f666364924a9\"\n\n\n\n{\n\n\n:feature-columns [:sex :pclass :embarked]\n\n\n:target-categorical-maps {:survived #tech.v3.dataset.categorical.CategoricalMap{:lookup-table {\"no\" 0, \"yes\" 1}, :src-column :survived, :result-datatype :float64}}\n\n\n:target-columns [:survived]\n\n\n:scicloj.metamorph.ml/unsupervised? nil\n\n\n\n\n\n\n\n\n\n:scicloj.metamorph.ml/feature-ds\n\n\n\nGroup: 0 [178 3]:\n\n\n\n:sex\n:pclass\n:embarked\n\n\n\n\n0.0\n3.0\n0.0\n\n\n1.0\n1.0\n2.0\n\n\n1.0\n1.0\n0.0\n\n\n1.0\n2.0\n0.0\n\n\n0.0\n3.0\n1.0\n\n\n0.0\n1.0\n0.0\n\n\n0.0\n3.0\n2.0\n\n\n1.0\n1.0\n2.0\n\n\n0.0\n2.0\n0.0\n\n\n0.0\n1.0\n2.0\n\n\n...\n...\n...\n\n\n0.0\n1.0\n0.0\n\n\n1.0\n3.0\n2.0\n\n\n0.0\n3.0\n0.0\n\n\n0.0\n1.0\n0.0\n\n\n1.0\n3.0\n1.0\n\n\n0.0\n3.0\n1.0\n\n\n0.0\n3.0\n0.0\n\n\n0.0\n3.0\n2.0\n\n\n0.0\n1.0\n0.0\n\n\n0.0\n2.0\n0.0\n\n\n1.0\n3.0\n0.0\n\n\n\n\n\n\n\n\n\n:model-data {:majority-class 1.0, :distinct-labels (0.0 1.0)}\n\n\n:id #uuid \"90771c94-150a-4d39-ae15-3eb88d9fb897\"\n\n\n\n\n\n\n\n\n\n:scicloj.metamorph.ml/target-ds\n\n\n\nGroup: 0 [178 1]:\n\n\n\n:survived\n\n\n\n\n0.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n0.0\n\n\n1.0\n\n\n0.0\n\n\n1.0\n\n\n0.0\n\n\n1.0\n\n\n...\n\n\n1.0\n\n\n0.0\n\n\n0.0\n\n\n1.0\n\n\n1.0\n\n\n1.0\n\n\n0.0\n\n\n1.0\n\n\n1.0\n\n\n0.0\n\n\n1.0\n\n\n\n\n\n\n\n\n\n:options {:model-type :metamorph.ml/dummy-classifier}\n\n\n}\n\n\n\n\n\n}\n\n\n\n\n(-&gt; ctx-after-predict :metamorph/data :survived)\n\n\n#tech.v3.dataset.column&lt;float64&gt;[178]\n:survived\n[1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000...]",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>AutoML using metamorph pipelines</span>"
    ]
  },
  {
    "objectID": "noj_book.automl.html#use-metamorph-pipelines-to-do-model-training-with-higher-level-api",
    "href": "noj_book.automl.html#use-metamorph-pipelines-to-do-model-training-with-higher-level-api",
    "title": "4¬† AutoML using metamorph pipelines",
    "section": "4.2 Use metamorph pipelines to do model training with higher level API",
    "text": "4.2 Use metamorph pipelines to do model training with higher level API\nAs user of metamorph.ml we do not need to deal with this low-level details of how metamorph works, we have convenience functions which hide this\nThe following code will do the same as train, but return a context object, which contains the trained model, so it will execute the pipeline, and not only create it.\nIt uses a convenience function mm/fit which generates compliant context maps internally and executes the pipeline as well.\nThe ctx acts a collector of everything ‚Äúlearned‚Äù during :fit, mainly the trained model, but it could be as well other information learned from the data during :fit and to be applied at :transform .\n\n(def train-ctx\n  (mm/fit titanic\n          (ml/model {:model-type :metamorph.ml/dummy-classifier})))\n\n(The dummy-classifier model does not have a lot of state, so there is little to see)\n\ntrain-ctx\n\n\n{\n\n\n\n\n\n\n\n\n:metamorph/data\n\n\n\n_unnamed [889 4]:\n\n\n\n:sex\n:pclass\n:embarked\n:survived\n\n\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n1.0\n1.0\n2.0\n1.0\n\n\n1.0\n3.0\n0.0\n1.0\n\n\n1.0\n1.0\n0.0\n1.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n0.0\n3.0\n1.0\n0.0\n\n\n0.0\n1.0\n0.0\n0.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n1.0\n3.0\n0.0\n1.0\n\n\n1.0\n2.0\n2.0\n1.0\n\n\n...\n...\n...\n...\n\n\n1.0\n2.0\n0.0\n1.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n1.0\n3.0\n0.0\n0.0\n\n\n0.0\n2.0\n0.0\n0.0\n\n\n0.0\n3.0\n0.0\n0.0\n\n\n1.0\n3.0\n1.0\n0.0\n\n\n0.0\n2.0\n0.0\n0.0\n\n\n1.0\n1.0\n0.0\n1.0\n\n\n1.0\n3.0\n0.0\n0.0\n\n\n0.0\n1.0\n2.0\n1.0\n\n\n0.0\n3.0\n1.0\n0.0\n\n\n\n\n\n\n\n\n:metamorph/mode :fit#uuid \"7e4d6419-de8e-4c93-8f3c-a77b4e40f5a8\" {:model-data {:majority-class 1, :distinct-labels (0.0 1.0)}, :options {:model-type :metamorph.ml/dummy-classifier}, :id #uuid \"09b4ae8f-3479-4d8f-8c38-cc3324ac265e\", :feature-columns [:sex :pclass :embarked], :target-columns [:survived], :target-categorical-maps {:survived #tech.v3.dataset.categorical.CategoricalMap{:lookup-table {\"no\" 0, \"yes\" 1}, :src-column :survived, :result-datatype :float64}}, :scicloj.metamorph.ml/unsupervised? nil}}\n\nTo show the power of pipelines, I start with doing the simplest possible pipeline, and expand then on it.\nwe can already chain train and test with usual functions:\n\n(-&gt;&gt;\n (ml/train train-ds {:model-type :metamorph.ml/dummy-classifier})\n (ml/predict test-ds)\n :survived)\n\n\n#tech.v3.dataset.column&lt;float64&gt;[178]\n:survived\n[1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000...]\n\nthe same with pipelines\n\n(def pipeline\n  (mm/pipeline (ml/model {:model-type :metamorph.ml/dummy-classifier})))\n\n\n(-&gt;&gt;\n (mm/fit-pipe train-ds pipeline)\n (mm/transform-pipe test-ds pipeline)\n :metamorph/data :survived)\n\n\n#tech.v3.dataset.column&lt;float64&gt;[178]\n:survived\n[1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000, 1.000...]",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>AutoML using metamorph pipelines</span>"
    ]
  },
  {
    "objectID": "noj_book.automl.html#create-metamorph-compliant-functions",
    "href": "noj_book.automl.html#create-metamorph-compliant-functions",
    "title": "4¬† AutoML using metamorph pipelines",
    "section": "4.3 Create metamorph compliant functions",
    "text": "4.3 Create metamorph compliant functions\nAs said before, a metamorph pipeline is composed of metamorph compliant functions / operations, which take as input and output the ctx. There are three ways to create those.\nThe following three expressions create the same metamorph compliant function\n\nimplementing a metamorph compliant function directly via anonymous function\n\n\n(def ops (fn [ctx]\n            (assoc ctx :metamorph/data\n                 (tc/drop-columns (:metamorph/data ctx) [:embarked]))))\n\n\nusing mm/lift which does the same as 1.\n\n\n(def ops (mm/lift tc/drop-columns [:embarked]))\n\n\nusing a name-space containing lifted functions\n\n\n(require '[tablecloth.pipeline])\n\n\n(def ops (tablecloth.pipeline/drop-columns [:embarked]))\n\nAll three create the same pipeline op and can be used to make a pipeline\n\n(mm/pipeline ops)\n\n\n#function[clojure.core/partial/fn--5908]\n\nPipeline as data is as well supported\n\n(def op-spec [[ml/model {:model-type :metamorph.ml/dummy-classifier}]])\n\n\n(mm/-&gt;pipeline op-spec)\n\n\n#function[clojure.core/partial/fn--5908]\n\nAll these do not execute anything, they produce functions which can be executed against a context as part of a metamorph pipeline.\nThe mm/lift function transposes any dataset-&gt;dataset functions into a ctx-&gt;ctx function, while using the metamorh convention, as required for metamorph pipeline operations\nFor convenience tablecloth contains a ns where all dataset-&gt;dataset functions are lifted into ctx-&gt;ctx operations, so can be added to pipelines directly without using lift.\nSo a metamorph pipeline can encapsulate arbitray transformation of a dataset in the 2 modes. They can be ‚Äústateless‚Äù (only chaining the dataset, such as drop-columns) or ‚Äústate-full‚Äù, so they store data in the ctx during :fit and can use it in :transform. In the pipeline above, the trained model is stored in this way.\nThis state is not stored globaly, but inside the pipeline so this makes pipeline execution ‚Äúisolated‚Äù.\nSo now we can add more operations to the pipeline, and nothing else changes, for example drop columns.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>AutoML using metamorph pipelines</span>"
    ]
  },
  {
    "objectID": "noj_book.automl.html#automatic-ml-with-metamorph.ml",
    "href": "noj_book.automl.html#automatic-ml-with-metamorph.ml",
    "title": "4¬† AutoML using metamorph pipelines",
    "section": "4.4 Automatic ML with metamorph.ml",
    "text": "4.4 Automatic ML with metamorph.ml\nThe AutoML support in metamorph.ml consists now in the possibility to create an arbitrary number of different pipelines and have them run against arbitray test/train data splits and it automatically chooses the best model evaluated by by a certain metric.\nhelper for later\n\n(defn make-results-ds [evaluation-results]\n  (-&gt;&gt; evaluation-results\n       flatten\n       (map #(hash-map :options (-&gt; % :test-transform :ctx :model :options)\n                       :used-features (-&gt; % :fit-ctx :used-features)\n                       :mean-accuracy (-&gt; % :test-transform :mean)))\n       tc/dataset))\n\n\n(require '[scicloj.metamorph.ml :as ml]\n         '[scicloj.metamorph.ml.loss :as loss]\n         '[scicloj.metamorph.core :as mm]\n         '[scicloj.ml.tribuo])",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>AutoML using metamorph pipelines</span>"
    ]
  },
  {
    "objectID": "noj_book.automl.html#finding-the-best-model-automatically",
    "href": "noj_book.automl.html#finding-the-best-model-automatically",
    "title": "4¬† AutoML using metamorph pipelines",
    "section": "4.5 Finding the best model automatically",
    "text": "4.5 Finding the best model automatically\nThe advantage of the pipelines is even more visible, if we want to have configurable pipelines, and do a grid search to find optimal settings.\nthe following will find the best model across:\n\n6 different model classes\n6 different selections of used features\nk-cross validate this with different test / train splits\n\n\n(defn make-pipe-fn [model-spec features]\n  (mm/pipeline\n   ;; store the used features in ctx, so we can retrieve them at the end\n   (fn [ctx]\n     (assoc ctx :used-features features))\n   (mm/lift tc/select-columns (conj features :survived))\n   {:metamorph/id :model} (ml/model model-spec)))\n\nCreate a 5-K cross validation split of the data:\n\n(def titanic-k-fold (tc/split-&gt;seq ml-basic/numeric-titanic-data :kfold {:seed 12345}))\n\nThe list of the model types we want to try:\n\n(def models [{:model-type :metamorph.ml/dummy-classifier}\n             {:model-type :smile.classification/random-forest}\n             {:model-type :smile.classification/logistic-regression}\n             {:model-type :smile.classification/decision-tree}\n             {:model-type :smile.classification/ada-boost}\n             {:model-type :scicloj.ml.tribuo/classification\n              :tribuo-components [{:name \"trainer\"\n                                   :type \"org.tribuo.classification.dtree.CARTClassificationTrainer\"\n                                   :properties {:maxDepth \"8\"\n                                                :useRandomSplitPoints \"false\"\n                                                :fractionFeaturesInSplit \"0.5\"}}]\n              :tribuo-trainer-name \"trainer\"}])\n\nThis uses models from Smile and Tribuo, but could be any metamorph.ml compliant model ( library sklearn-clj wraps all python sklearn models, for example)\nThe list of feature combinations to try for each model:\n\n(def feature-combinations\n  [[:sex :pclass :embarked]\n   [:sex]\n   [:pclass :embarked]\n   [:embarked]\n   [:sex :embarked]\n   [:sex :pclass]])\n\ngenerate 36 pipeline functions:\n\n(def pipe-fns\n  (for [model models\n        feature-combination feature-combinations]\n    (make-pipe-fn model feature-combination)))\n\nExceute all pipelines for all splits in the cross-validations and return best model by classification-accuracy\n\n(def evaluation-results\n  (ml/evaluate-pipelines\n   pipe-fns\n   titanic-k-fold\n   loss/classification-accuracy\n   :accuracy))\n\nBy default it returns the best mode only\n\n(make-results-ds evaluation-results)\n\n\n_unnamed [1 3]:\n\n\n\n\n\n\n\n\n:used-features\n:mean-accuracy\n:options\n\n\n\n\n[:sex :pclass :embarked]\n0.81107726\n{:model-type :scicloj.ml.tribuo/classification,\n\n\n\n\n:tribuo-components\n\n\n\n\n[{:name trainer,\n\n\n\n\n:type org.tribuo.classification.dtree.CARTClassificationTrainer,\n\n\n\n\n:properties\n\n\n\n\n{:maxDepth 8,\n\n\n\n\n:useRandomSplitPoints false,\n\n\n\n\n:fractionFeaturesInSplit 0.5}}],\n\n\n\n\n:tribuo-trainer-name trainer}\n\n\n\n\nThe key observation is here, that the metamorph pipelines allow to not only grid-search over the model hyper-parameters, but as well over arbitrary pipeline variations, like which features to include. Both get handled in the same way.\nWe can get all results as well:\n\n(def evaluation-results-all\n  (ml/evaluate-pipelines\n   pipe-fns\n   titanic-k-fold\n   loss/classification-accuracy\n   :accuracy\n   {:return-best-crossvalidation-only false\n    :return-best-pipeline-only false}))\n\nIn total it creates and evaluates 6 models * 6 feature configurarions * 5 CV = 180 models\n\n(-&gt;  evaluation-results-all flatten count)\n\n\n180\n\nWe can find the best as well by hand, it‚Äôs the first from the list, when sorted by accuracy.\n\n(-&gt; (make-results-ds evaluation-results-all)\n    (tc/unique-by)\n    (tc/order-by [:mean-accuracy] :desc)\n    (tc/head))\n\n\n_unnamed [5 3]:\n\n\n\n\n\n\n\n\n:used-features\n:mean-accuracy\n:options\n\n\n\n\n[:sex :pclass :embarked]\n0.81107726\n{:model-type :scicloj.ml.tribuo/classification,\n\n\n\n\n:tribuo-components\n\n\n\n\n[{:name trainer,\n\n\n\n\n:type org.tribuo.classification.dtree.CARTClassificationTrainer,\n\n\n\n\n:properties\n\n\n\n\n{:maxDepth 8,\n\n\n\n\n:useRandomSplitPoints false,\n\n\n\n\n:fractionFeaturesInSplit 0.5}}],\n\n\n\n\n:tribuo-trainer-name trainer}\n\n\n[:sex :pclass :embarked]\n0.81107726\n{:model-type :smile.classification/ada-boost}\n\n\n[:sex]\n0.78633276\n{:model-type :smile.classification/logistic-regression}\n\n\n[:sex]\n0.78633276\n{:model-type :scicloj.ml.tribuo/classification,\n\n\n\n\n:tribuo-components\n\n\n\n\n[{:name trainer,\n\n\n\n\n:type org.tribuo.classification.dtree.CARTClassificationTrainer,\n\n\n\n\n:properties\n\n\n\n\n{:maxDepth 8,\n\n\n\n\n:useRandomSplitPoints false,\n\n\n\n\n:fractionFeaturesInSplit 0.5}}],\n\n\n\n\n:tribuo-trainer-name trainer}\n\n\n[:sex :embarked]\n0.78633276\n{:model-type :smile.classification/ada-boost}",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>AutoML using metamorph pipelines</span>"
    ]
  },
  {
    "objectID": "noj_book.automl.html#best-practices-for-data-transformation-steps-in-or-outside-pipeline",
    "href": "noj_book.automl.html#best-practices-for-data-transformation-steps-in-or-outside-pipeline",
    "title": "4¬† AutoML using metamorph pipelines",
    "section": "4.6 Best practices for data transformation steps in or outside pipeline",
    "text": "4.6 Best practices for data transformation steps in or outside pipeline\n\n(require '[scicloj.metamorph.ml.toydata :as data]\n         '[tech.v3.dataset.modelling :as ds-mod]\n         '[tech.v3.dataset.categorical :as ds-cat]\n         '[tech.v3.dataset :as ds])\n\nWe have seen that we have two ways to transform the input data, outside the pipeline and inside the pipeline.\nThese are the total steps from raw data to ‚Äúinto the model‚Äù for the titanic use case.\n\nraw data\n\n\n(def titanic\n  (:train\n   (data/titanic-ds-split)))\n\n\nfirst transformation, no metamorph pipeline\n\n\n(def relevant-titanic-data\n  (-&gt; titanic\n      (tc/select-columns (conj ml-basic/categorical-feature-columns :survived))\n      (tc/drop-missing)\n      (ds/categorical-&gt;number [:sex :pclass :embarked] [0 1 2 \"male\" \"female\" \"S\" \"Q\" \"C\"] :float64)\n      (ds/categorical-&gt;number [:survived] [0 1] :float64)\n      (ds-mod/set-inference-target :survived)))\n\n\ntransform via pipelines\n\n\n(defn make-pipe-fn [model-type features]\n  (mm/pipeline\n   ;; store the used features in ctx, so we can retrieve them at the end\n   (fn [ctx]\n     (assoc ctx :used-features features))\n   (mm/lift tc/select-columns (conj features :survived))\n   {:metamorph/id :model} (ml/model {:model-type model-type})))\n\nWhile it would be technically possible to move all steps from the ‚Äúfirst transformation‚Äù into the pipeline, by just using the ‚Äúlifted‚Äù form of the transformations, I would not do so, even though this should give the same result.\nI think it is better to separate the steps which are ‚Äúfixed‚Äù, from the steps which are parameterized, so for which we want to find the best values by ‚Äútrying out‚Äù.\nIn my view there are two reasons for this: 1. Debugging: It is harder to debug a pipeline and see the results of steps. We have one macro helping in this: mm/def-ctx 2. Performance: The pipeline is executed lots of times, for every split / variant of the pipeline. It should be faster to do things only once, before the pipeline\n\nsource: notebooks/noj_book/automl.clj",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>AutoML using metamorph pipelines</span>"
    ]
  },
  {
    "objectID": "noj_book.interactions_ols.html",
    "href": "noj_book.interactions_ols.html",
    "title": "5¬† Ordinary least squares with interactions",
    "section": "",
    "text": "5.1 Additive model\nFirst we build an additive model, which model equation is \\[sales = b0 + b1 * youtube + b2 * facebook\\]\nWe evaluate it,\nand print the result:\nWe have the following metrics:\n\\(RMSE\\)\n\\(R^2\\)",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Ordinary least squares with interactions</span>"
    ]
  },
  {
    "objectID": "noj_book.interactions_ols.html#additive-model",
    "href": "noj_book.interactions_ols.html#additive-model",
    "title": "5¬† Ordinary least squares with interactions",
    "section": "",
    "text": "(def additive-pipeline\n  (mm/pipeline\n   {:metamorph/id :model}\n   (ml/model {:model-type :smile.regression/ordinary-least-square})))\n\n\n\n(def evaluations\n  (ml/evaluate-pipelines\n   [additive-pipeline]\n   (tc/split-&gt;seq preprocessed-data :holdout)\n   loss/rmse\n   :loss\n   {:other-metrices [{:name :r2\n                      :metric-fn fmstats/r2-determination}]}))\n\n\n\n(-&gt; evaluations flatten first :fit-ctx :model ml/thaw-model)\n\n\nLinear Model:\n\nResiduals:\n       Min          1Q      Median          3Q         Max\n  -10.1808     -1.2477      0.3855      1.4717      3.5701\n\nCoefficients:\n                  Estimate Std. Error    t value   Pr(&gt;|t|)\nIntercept           3.2517     0.4605     7.0615     0.0000 ***\nyoutube             0.0468     0.0018    26.4844     0.0000 ***\nfacebook            0.1854     0.0106    17.4187     0.0000 ***\n---------------------------------------------------------------------\nSignificance codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.1636 on 130 degrees of freedom\nMultiple R-squared: 0.8857,    Adjusted R-squared: 0.8840\nF-statistic: 503.8707 on 3 and 130 DF,  p-value: 5.801e-62\n\n\n\n\n(-&gt; evaluations flatten first :test-transform :metric)\n\n\n1.7293393770640264\n\n\n\n(-&gt; evaluations flatten first :test-transform :other-metrices first :metric)\n\n\n0.9223737393827188",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Ordinary least squares with interactions</span>"
    ]
  },
  {
    "objectID": "noj_book.interactions_ols.html#interaction-effects",
    "href": "noj_book.interactions_ols.html#interaction-effects",
    "title": "5¬† Ordinary least squares with interactions",
    "section": "5.2 Interaction effects",
    "text": "5.2 Interaction effects\nNow we add interaction effects to it, resulting in this model equation: \\[sales = b0 + b1 * youtube + b2 * facebook + b3 * (youtube * facebook)\\]\n\n(def pipe-interaction\n  (mm/pipeline\n   (tcpipe/add-column :youtube*facebook (fn [ds] (tcc/* (ds :youtube) (ds :facebook))))\n   {:metamorph/id :model}(ml/model {:model-type :smile.regression/ordinary-least-square})))\n\nAgain we evaluate the model,\n\n(def evaluations\n  (ml/evaluate-pipelines\n   [pipe-interaction]\n   (tc/split-&gt;seq preprocessed-data :holdout)\n   loss/rmse\n   :loss\n   {:other-metrices [{:name :r2\n                      :metric-fn fmstats/r2-determination}]}))\n\nand print it and the performance metrices:\n\n(-&gt; evaluations flatten first :fit-ctx :model ml/thaw-model)\n\n\nLinear Model:\n\nResiduals:\n       Min          1Q      Median          3Q         Max\n   -4.5744     -0.5438      0.2698      0.6643      1.7632\n\nCoefficients:\n                  Estimate Std. Error    t value   Pr(&gt;|t|)\nIntercept           7.4629     0.3168    23.5596     0.0000 ***\nyoutube             0.0220     0.0017    13.0535     0.0000 ***\nfacebook            0.0567     0.0098     5.7697     0.0000 ***\nyoutube*facebook     0.0008     0.0000    15.8067     0.0000 ***\n---------------------------------------------------------------------\nSignificance codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.0261 on 129 degrees of freedom\nMultiple R-squared: 0.9734,    Adjusted R-squared: 0.9728\nF-statistic: 1573.5134 on 4 and 129 DF,  p-value: 2.287e-101\n\nAs the multiplcation of youtube*facebook is as well statistically relevant, it suggests that there is indeed an interaction between these 2 predictor variables youtube and facebook.\n\\(RMSE\\)\n\n(-&gt; evaluations flatten first :test-transform :metric)\n\n\n1.3886192343479014\n\n\\(R^2\\)\n\n(-&gt; evaluations flatten first :test-transform :other-metrices first :metric)\n\n\n0.9526434225525324\n\n\\(RMSE\\) and \\(R^2\\) of the intercation model are sligtly better.\nThese results suggest that the model with the interaction term is better than the model that contains only main effects. So, for this specific data, we should go for the model with the interaction model.\n\nsource: notebooks/noj_book/interactions_ols.clj",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Ordinary least squares with interactions</span>"
    ]
  },
  {
    "objectID": "noj_book.datasets.html",
    "href": "noj_book.datasets.html",
    "title": "6¬† Datasets",
    "section": "",
    "text": "author: Daniel Slutsky\n\n(ns noj-book.datasets\n  (:require [tablecloth.api :as tc]))\n\nFor our tutorials here, let us fetch some datasets from Rdatasets\n\n(def iris\n  (-&gt; \"https://vincentarelbundock.github.io/Rdatasets/csv/datasets/iris.csv\"\n      (tc/dataset {:key-fn keyword})\n      (tc/rename-columns {:Sepal.Length :sepal-length\n                          :Sepal.Width :sepal-width\n                          :Petal.Length :petal-length\n                          :Petal.Width :petal-width\n                          :Species :species})))\n\n\niris\n\n\nhttps://vincentarelbundock.github.io/Rdatasets/csv/datasets/iris.csv [150 6]:\n\n\n\n\n\n\n\n\n\n\n\n:rownames\n:sepal-length\n:sepal-width\n:petal-length\n:petal-width\n:species\n\n\n\n\n1\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n2\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n3\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n4\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n5\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n6\n5.4\n3.9\n1.7\n0.4\nsetosa\n\n\n7\n4.6\n3.4\n1.4\n0.3\nsetosa\n\n\n8\n5.0\n3.4\n1.5\n0.2\nsetosa\n\n\n9\n4.4\n2.9\n1.4\n0.2\nsetosa\n\n\n10\n4.9\n3.1\n1.5\n0.1\nsetosa\n\n\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n\n\n140\n6.9\n3.1\n5.4\n2.1\nvirginica\n\n\n141\n6.7\n3.1\n5.6\n2.4\nvirginica\n\n\n142\n6.9\n3.1\n5.1\n2.3\nvirginica\n\n\n143\n5.8\n2.7\n5.1\n1.9\nvirginica\n\n\n144\n6.8\n3.2\n5.9\n2.3\nvirginica\n\n\n145\n6.7\n3.3\n5.7\n2.5\nvirginica\n\n\n146\n6.7\n3.0\n5.2\n2.3\nvirginica\n\n\n147\n6.3\n2.5\n5.0\n1.9\nvirginica\n\n\n148\n6.5\n3.0\n5.2\n2.0\nvirginica\n\n\n149\n6.2\n3.4\n5.4\n2.3\nvirginica\n\n\n150\n5.9\n3.0\n5.1\n1.8\nvirginica\n\n\n\n\n\n(def mtcars\n  (-&gt; \"https://vincentarelbundock.github.io/Rdatasets/csv/datasets/mtcars.csv\"\n      (tc/dataset {:key-fn keyword})))\n\n\nmtcars\n\n\nhttps://vincentarelbundock.github.io/Rdatasets/csv/datasets/mtcars.csv [32 12]:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n:rownames\n:mpg\n:cyl\n:disp\n:hp\n:drat\n:wt\n:qsec\n:vs\n:am\n:gear\n:carb\n\n\n\n\nMazda RX4\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\nMazda RX4 Wag\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\nDatsun 710\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\nHornet 4 Drive\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\nHornet Sportabout\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\nValiant\n18.1\n6\n225.0\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n\n\nDuster 360\n14.3\n8\n360.0\n245\n3.21\n3.570\n15.84\n0\n0\n3\n4\n\n\nMerc 240D\n24.4\n4\n146.7\n62\n3.69\n3.190\n20.00\n1\n0\n4\n2\n\n\nMerc 230\n22.8\n4\n140.8\n95\n3.92\n3.150\n22.90\n1\n0\n4\n2\n\n\nMerc 280\n19.2\n6\n167.6\n123\n3.92\n3.440\n18.30\n1\n0\n4\n4\n\n\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n\n\nDodge Challenger\n15.5\n8\n318.0\n150\n2.76\n3.520\n16.87\n0\n0\n3\n2\n\n\nAMC Javelin\n15.2\n8\n304.0\n150\n3.15\n3.435\n17.30\n0\n0\n3\n2\n\n\nCamaro Z28\n13.3\n8\n350.0\n245\n3.73\n3.840\n15.41\n0\n0\n3\n4\n\n\nPontiac Firebird\n19.2\n8\n400.0\n175\n3.08\n3.845\n17.05\n0\n0\n3\n2\n\n\nFiat X1-9\n27.3\n4\n79.0\n66\n4.08\n1.935\n18.90\n1\n1\n4\n1\n\n\nPorsche 914-2\n26.0\n4\n120.3\n91\n4.43\n2.140\n16.70\n0\n1\n5\n2\n\n\nLotus Europa\n30.4\n4\n95.1\n113\n3.77\n1.513\n16.90\n1\n1\n5\n2\n\n\nFord Pantera L\n15.8\n8\n351.0\n264\n4.22\n3.170\n14.50\n0\n1\n5\n4\n\n\nFerrari Dino\n19.7\n6\n145.0\n175\n3.62\n2.770\n15.50\n0\n1\n5\n6\n\n\nMaserati Bora\n15.0\n8\n301.0\n335\n3.54\n3.570\n14.60\n0\n1\n5\n8\n\n\nVolvo 142E\n21.4\n4\n121.0\n109\n4.11\n2.780\n18.60\n1\n1\n4\n2\n\n\n\n\n\nsource: notebooks/noj_book/datasets.clj",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Datasets</span>"
    ]
  },
  {
    "objectID": "noj_book.python.html",
    "href": "noj_book.python.html",
    "title": "7¬† Python (experimental üõ†)",
    "section": "",
    "text": "7.1 Using Python visualizations\nNoj offers methods to include Python plots in Kindly visualizations: the vis.python/with-pyplot macro and the vis.python/pyplot function.\nThey are based on the Parens for Pyplot blog post at Squid‚Äôs blog.\nhttps://seaborn.pydata.org/tutorial/introduction",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Python (experimental üõ†)</span>"
    ]
  },
  {
    "objectID": "noj_book.python.html#using-python-visualizations",
    "href": "noj_book.python.html#using-python-visualizations",
    "title": "7¬† Python (experimental üõ†)",
    "section": "",
    "text": "(require-python '[numpy :as np]\n                '[numpy.random :as np.random]\n                'matplotlib.pyplot\n                '[seaborn :as sns]\n                'json)\n\n\n:ok\n\n\n(def sine-data\n  (-&gt; {:x (range 0 (* 3 np/pi) 0.1)}\n      tc/dataset\n      (tc/add-column :y #(tcc/sin (:x %)))))\n\n\n(vis.python/with-pyplot\n  (matplotlib.pyplot/plot\n   (:x sine-data)\n   (:y sine-data)))\n\n\n\n(vis.python/pyplot\n #(matplotlib.pyplot/plot\n   (:x sine-data)\n   (:y sine-data)))\n\n\n\n\n(let [tips (sns/load_dataset \"tips\")]\n  (sns/set_theme)\n  (vis.python/pyplot\n   #(sns/relplot :data tips\n                 :x \"total_bill\"\n                 :y \"tip\"\n                 :col \"time\"\n                 :hue \"smoker\"\n                 :style \"smoker\"\n                 :size \"size\")))\n\n\n\n:bye\n\n\n:bye\n\n\nsource: notebooks/noj_book/python.clj",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Python (experimental üõ†)</span>"
    ]
  },
  {
    "objectID": "noj_book.statistics.html",
    "href": "noj_book.statistics.html",
    "title": "8¬† Statistics (experimental üõ†)",
    "section": "",
    "text": "8.1 Example data",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Statistics (experimental üõ†)</span>"
    ]
  },
  {
    "objectID": "noj_book.statistics.html#example-data",
    "href": "noj_book.statistics.html#example-data",
    "title": "8¬† Statistics (experimental üõ†)",
    "section": "",
    "text": "(def iris\n  (-&gt; \"https://vincentarelbundock.github.io/Rdatasets/csv/datasets/iris.csv\"\n      (tc/dataset {:key-fn keyword})\n      (tc/rename-columns {:Sepal.Length :sepal-length\n                          :Sepal.Width :sepal-width\n                          :Petal.Length :petal-length\n                          :Petal.Width :petal-width\n                          :Species :species})))",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Statistics (experimental üõ†)</span>"
    ]
  },
  {
    "objectID": "noj_book.statistics.html#multivariate-regression",
    "href": "noj_book.statistics.html#multivariate-regression",
    "title": "8¬† Statistics (experimental üõ†)",
    "section": "8.2 Multivariate regression",
    "text": "8.2 Multivariate regression\nThe stats/regression-model function computes a regressiom model (using scicloj.ml) and adds some relevant information such as the R^2 measure.\n\n(-&gt; iris\n    (stats/regression-model\n     :sepal-length\n     [:sepal-width :petal-length :petal-width]\n     {:model-type :smile.regression/elastic-net})\n    (dissoc :model-data))\n\n\n{:feature-columns [:sepal-width :petal-length :petal-width],\n :target-columns [:sepal-length],\n :explained #function[clojure.lang.AFunction/1],\n :R2 0.8582120394596505,\n :id #uuid \"f1a76711-8013-47a1-968a-82248d961ebd\",\n :predictions #tech.v3.dataset.column&lt;float64&gt;[150]\n:sepal-length\n[5.022, 4.724, 4.775, 4.851, 5.081, 5.360, 4.911, 5.030, 4.664, 4.903, 5.209, 5.098, 4.775, 4.572, 5.184, 5.522, 5.089, 4.970, 5.352, 5.217...],\n :predict\n #function[scicloj.noj.v1.stats/regression-model/predict--72850],\n :options {:model-type :smile.regression/elastic-net}}\n\n\n(-&gt; iris\n    (stats/regression-model\n     :sepal-length\n     [:sepal-width :petal-length :petal-width]\n     {:model-type :smile.regression/ordinary-least-square})\n    (dissoc :model-data))\n\n\n{:feature-columns [:sepal-width :petal-length :petal-width],\n :target-columns [:sepal-length],\n :explained #function[clojure.lang.AFunction/1],\n :R2 0.8586117200663171,\n :id #uuid \"683c846e-7681-43dd-8f82-4e2d9923755e\",\n :predictions #tech.v3.dataset.column&lt;float64&gt;[150]\n:sepal-length\n[5.015, 4.690, 4.749, 4.826, 5.080, 5.377, 4.895, 5.021, 4.625, 4.882, 5.216, 5.092, 4.746, 4.533, 5.199, 5.561, 5.094, 4.960, 5.368, 5.226...],\n :predict\n #function[scicloj.noj.v1.stats/regression-model/predict--72850],\n :options {:model-type :smile.regression/ordinary-least-square}}\n\nThe stats/linear-regression-model convenience function uses specifically the :smile.regression/ordinary-least-square model type.\n\n(-&gt; iris\n    (stats/linear-regression-model\n     :sepal-length\n     [:sepal-width :petal-length :petal-width])\n    (dissoc :model-data))\n\n\n{:feature-columns [:sepal-width :petal-length :petal-width],\n :target-columns [:sepal-length],\n :explained #function[clojure.lang.AFunction/1],\n :R2 0.8586117200663171,\n :id #uuid \"ba1d5dcb-77a3-4cc0-8518-efb291f98cf0\",\n :predictions #tech.v3.dataset.column&lt;float64&gt;[150]\n:sepal-length\n[5.015, 4.690, 4.749, 4.826, 5.080, 5.377, 4.895, 5.021, 4.625, 4.882, 5.216, 5.092, 4.746, 4.533, 5.199, 5.561, 5.094, 4.960, 5.368, 5.226...],\n :predict\n #function[scicloj.noj.v1.stats/regression-model/predict--72850],\n :options {:model-type :smile.regression/ordinary-least-square}}",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Statistics (experimental üõ†)</span>"
    ]
  },
  {
    "objectID": "noj_book.statistics.html#adding-regression-predictions-to-a-dataset",
    "href": "noj_book.statistics.html#adding-regression-predictions-to-a-dataset",
    "title": "8¬† Statistics (experimental üõ†)",
    "section": "8.3 Adding regression predictions to a dataset",
    "text": "8.3 Adding regression predictions to a dataset\nThe stats/add-predictions function models a target column using feature columns, adds a new prediction column with the model predictions.\n\n(-&gt; iris\n    (stats/add-predictions\n     :sepal-length\n     [:sepal-width :petal-length :petal-width]\n     {:model-type :smile.regression/ordinary-least-square}))\n\n\nhttps://vincentarelbundock.github.io/Rdatasets/csv/datasets/iris.csv [150 7]:\n\n\n\n\n\n\n\n\n\n\n\n\n:rownames\n:sepal-length\n:sepal-width\n:petal-length\n:petal-width\n:species\n:sepal-length-prediction\n\n\n\n\n1\n5.1\n3.5\n1.4\n0.2\nsetosa\n5.01541576\n\n\n2\n4.9\n3.0\n1.4\n0.2\nsetosa\n4.68999718\n\n\n3\n4.7\n3.2\n1.3\n0.2\nsetosa\n4.74925142\n\n\n4\n4.6\n3.1\n1.5\n0.2\nsetosa\n4.82599409\n\n\n5\n5.0\n3.6\n1.4\n0.2\nsetosa\n5.08049948\n\n\n6\n5.4\n3.9\n1.7\n0.4\nsetosa\n5.37719368\n\n\n7\n4.6\n3.4\n1.4\n0.3\nsetosa\n4.89468378\n\n\n8\n5.0\n3.4\n1.5\n0.2\nsetosa\n5.02124524\n\n\n9\n4.4\n2.9\n1.4\n0.2\nsetosa\n4.62491347\n\n\n10\n4.9\n3.1\n1.5\n0.1\nsetosa\n4.88164236\n\n\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n\n\n140\n6.9\n3.1\n5.4\n2.1\nvirginica\n6.53429168\n\n\n141\n6.7\n3.1\n5.6\n2.4\nvirginica\n6.50917327\n\n\n142\n6.9\n3.1\n5.1\n2.3\nvirginica\n6.21025556\n\n\n143\n5.8\n2.7\n5.1\n1.9\nvirginica\n6.17251376\n\n\n144\n6.8\n3.2\n5.9\n2.3\nvirginica\n6.84264484\n\n\n145\n6.7\n3.3\n5.7\n2.5\nvirginica\n6.65460564\n\n\n146\n6.7\n3.0\n5.2\n2.3\nvirginica\n6.21608504\n\n\n147\n6.3\n2.5\n5.0\n1.9\nvirginica\n5.97143313\n\n\n148\n6.5\n3.0\n5.2\n2.0\nvirginica\n6.38302984\n\n\n149\n6.2\n3.4\n5.4\n2.3\nvirginica\n6.61824630\n\n\n150\n5.9\n3.0\n5.1\n1.8\nvirginica\n6.42341317\n\n\n\n\nIt attaches the model‚Äôs information to the metadata of that new column.\n\n(-&gt; iris\n    (stats/add-predictions\n     :sepal-length\n     [:sepal-width :petal-length :petal-width]\n     {:model-type :smile.regression/ordinary-least-square})\n    :sepal-length-prediction\n    meta\n    (update :model\n            dissoc :model-data :predict :predictions))\n\n\n{:name :sepal-length-prediction,\n :datatype :float64,\n :n-elems 150,\n :column-type :prediction,\n :model\n {:feature-columns [:sepal-width :petal-length :petal-width],\n  :target-columns [:sepal-length],\n  :explained #function[clojure.lang.AFunction/1],\n  :R2 0.8586117200663171,\n  :id #uuid \"46a10c23-fa99-49d9-9b92-f5dbefc6225a\",\n  :options {:model-type :smile.regression/ordinary-least-square}}}\n\n\nsource: notebooks/noj_book/statistics.clj",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Statistics (experimental üõ†)</span>"
    ]
  },
  {
    "objectID": "noj_book.visualization.html",
    "href": "noj_book.visualization.html",
    "title": "9¬† Visualization (experimental üõ†)",
    "section": "",
    "text": "9.1 Visualizing datases with Hanami\nNoj offers a few convenience functions to make Hanami plotting work smoothly with Tablecloth and Kindly.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Visualization (experimental üõ†)</span>"
    ]
  },
  {
    "objectID": "noj_book.visualization.html#visualizing-datases-with-hanami",
    "href": "noj_book.visualization.html#visualizing-datases-with-hanami",
    "title": "9¬† Visualization (experimental üõ†)",
    "section": "",
    "text": "(def random-walk\n  (let [n 20]\n    (-&gt; {:x (range n)\n         :y (-&gt;&gt; (repeatedly n #(- (rand) 0.5))\n                 (reductions +))}\n        tc/dataset)))\n\n\n9.1.1 A simple plot\nWe can plot a Tablecloth datasete using a Hanami template:\n\n(-&gt; random-walk\n    (vis.hanami/plot ht/point-chart\n                 {:MSIZE 200}))\n\n\nLet us look inside the resulting vega-lite space. We can see the dataset is included as CSV:\n\n(-&gt; random-walk\n    (vis.hanami/plot ht/point-chart\n                     {:MSIZE 200})\n    kind/pprint)\n\n\n{:encoding\n {:y {:field \"y\", :type \"quantitative\"},\n  :x {:field \"x\", :type \"quantitative\"}},\n :usermeta {:embedOptions {:renderer :svg}},\n :mark {:type \"circle\", :size 200, :tooltip true},\n :width 400,\n :background \"floralwhite\",\n :height 300,\n :data\n {:values\n  \"x,y\\n0,0.16971793498205567\\n1,0.5450088504889095\\n2,0.9197968118120425\\n3,1.3406356042002154\\n4,0.9839501943655178\\n5,0.9167010047929589\\n6,0.5872750928422811\\n7,1.069465550592227\\n8,1.240831526495136\\n9,1.603312092601753\\n10,1.194712277835514\\n11,1.3710058686208724\\n12,1.064628196169548\\n13,1.5407415264352151\\n14,1.748338196780922\\n15,2.0464446964744942\\n16,2.0554162965378793\\n17,1.764014199944095\\n18,1.7457684582606876\\n19,1.6273468740317754\\n\",\n  :format {:type \"csv\"}}}\n\n\n\n9.1.2 More examples\n\n(-&gt; datasets/mtcars\n    (vis.hanami/plot ht/boxplot-chart\n                     {:X :gear\n                      :XTYPE :nominal\n                      :Y :mpg}))\n\n\n\n(-&gt; datasets/iris\n    (vis.hanami/plot ht/rule-chart\n                     {:X :sepal-width\n                      :Y :sepal-length\n                      :X2 :petal-width\n                      :Y2 :petal-length\n                      :OPACITY 0.2\n                      :SIZE 3\n                      :COLOR \"species\"}))\n\n\n\n\n9.1.3 Grouped datasets\nGrouped datasets are handled automatically with a table view.\n\n(-&gt; datasets/iris\n    (tc/group-by [:species])\n    (vis.hanami/plot ht/rule-chart\n                     {:X :sepal-width\n                      :Y :sepal-length\n                      :X2 :petal-width\n                      :Y2 :petal-length\n                      :OPACITY 0.2\n                      :SIZE 3}))\n\n\n\n\n\n\n\n\n\n\n\nspecies\nplot\n\n\n\n\nsetosa\n\n\n\n\n\nversicolor\n\n\n\n\n\nvirginica\n\n\n\n\n\n\n\n\n\n\n\n9.1.4 Layers\n\n(-&gt; random-walk\n    (vis.hanami/layers\n     {:TITLE \"points and a line\"}\n     [(vis.hanami/plot nil\n                       ht/point-chart\n                       {:MSIZE 400})\n      (vis.hanami/plot nil\n                       ht/line-chart\n                       {:MSIZE 4\n                        :MCOLOR \"brown\"})]))\n\n\nAlternatively:\n\n(-&gt; random-walk\n    (vis.hanami/combined-plot\n     ht/layer-chart\n     {:TITLE \"points and a line\"}\n     :LAYER [[ht/point-chart\n              {:MSIZE 400}]\n             [ht/line-chart\n              {:MSIZE 4\n               :MCOLOR \"brown\"}]]))\n\n\n\n\n9.1.5 Concatenation\nVertical\n\n(-&gt; random-walk\n    (vis.hanami/vconcat\n     {}\n     [(vis.hanami/plot nil\n                       ht/point-chart\n                       {:MSIZE 400\n                        :HEIGHT 100\n                        :WIDTH 100})\n      (vis.hanami/plot nil\n                       ht/line-chart\n                       {:MSIZE 4\n                        :MCOLOR \"brown\"\n                        :HEIGHT 100\n                        :WIDTH 100})]))\n\n\nAlternatively:\n\n(-&gt; random-walk\n    (vis.hanami/combined-plot\n     ht/vconcat-chart\n     {:HEIGHT 100\n      :WIDTH 100}\n     :VCONCAT [[ht/point-chart\n                {:MSIZE 400}]\n               [ht/line-chart\n                {:MSIZE 4\n                 :MCOLOR \"brown\"}]]))\n\n\nHorizontal\n\n(-&gt; random-walk\n    (vis.hanami/hconcat\n     {}\n     [(vis.hanami/plot nil\n                       ht/point-chart\n                       {:MSIZE 400\n                        :HEIGHT 100\n                        :WIDTH 100})\n      (vis.hanami/plot nil\n                       ht/line-chart\n                       {:MSIZE 4\n                        :MCOLOR \"brown\"\n                        :HEIGHT 100\n                        :WIDTH 100})]))\n\n\nAlternatively:\n\n(-&gt; random-walk\n    (vis.hanami/combined-plot\n     ht/hconcat-chart\n     {:HEIGHT 100\n      :WIDTH 100}\n     :HCONCAT [[ht/point-chart\n                {:MSIZE 400}]\n               [ht/line-chart\n                {:MSIZE 4\n                 :MCOLOR \"brown\"}]]))\n\n\n\n:bye\n\n\n:bye\n\n\nsource: notebooks/noj_book/visualization.clj",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Visualization (experimental üõ†)</span>"
    ]
  },
  {
    "objectID": "noj_book.statistical_visualization.html",
    "href": "noj_book.statistical_visualization.html",
    "title": "10¬† Statistical Visualization (experimental üõ†)",
    "section": "",
    "text": "10.1 Linear regression\nAlternatively:\nAnd in a grouped dataset case:",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Statistical Visualization (experimental üõ†)</span>"
    ]
  },
  {
    "objectID": "noj_book.statistical_visualization.html#linear-regression",
    "href": "noj_book.statistical_visualization.html#linear-regression",
    "title": "10¬† Statistical Visualization (experimental üõ†)",
    "section": "",
    "text": "(-&gt; datasets/mtcars\n    (stats/add-predictions :mpg [:wt]\n                           {:model-type :smile.regression/ordinary-least-square})\n    (vis.hanami/combined-plot\n     ht/layer-chart\n     {:X :wt\n      :MSIZE 200\n      :HEIGHT 200}\n     :LAYER [[ht/point-chart\n              {:Y :mpg\n               :WIDTH 200}]\n             [ht/line-chart\n              {:Y :mpg-prediction\n               :MSIZE 5\n               :MCOLOR \"purple\"\n               :YTITLE :mpg}]]))\n\n\n\n\n(-&gt; datasets/mtcars\n    (vis.stats/linear-regression-plot\n     :mpg :wt\n     {:HEIGHT 200\n      :WIDTH 200\n      :point-options {:MSIZE 200}\n      :line-options {:MSIZE 5\n                     :MCOLOR \"purple\"}}))\n\n\n\n\n(-&gt; datasets/mtcars\n    (tc/group-by [:gear])\n    (vis.stats/linear-regression-plot\n     :mpg :wt\n     {:HEIGHT 200\n      :WIDTH 200\n      :point-options {:MSIZE 200}\n      :line-options {:MSIZE 5\n                     :MCOLOR \"purple\"}}))\n\n\n\n\n\n\n\n\n\n\n\ngear\nplot\n\n\n\n\n4\n\n\n\n\n\n3\n\n\n\n\n\n5",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Statistical Visualization (experimental üõ†)</span>"
    ]
  },
  {
    "objectID": "noj_book.statistical_visualization.html#histogram",
    "href": "noj_book.statistical_visualization.html#histogram",
    "title": "10¬† Statistical Visualization (experimental üõ†)",
    "section": "10.2 Histogram",
    "text": "10.2 Histogram\nA histogram groups values in bins, counts them, and creates a corresponding bar-chart.\nThe vis.stats/histogram functions does that behind the scenes, and generates a Vega-Lite spec using Hanami.\n\n(-&gt; datasets/iris\n    (vis.stats/histogram :sepal-width\n                         {:nbins 10}))\n\n\n\n(-&gt; datasets/iris\n    (vis.stats/histogram :sepal-width\n                         {:nbins 10})\n    kind/pprint)\n\n\n{:encoding\n {:y {:field :count, :type \"quantitative\"},\n  :x\n  {:field :left,\n   :type \"quantitative\",\n   :title :sepal-width,\n   :bin {:binned true, :step 0.24000000000000005}},\n  :x2 {:field :right, :type \"quantitative\"}},\n :usermeta {:embedOptions {:renderer :svg}},\n :mark {:type \"bar\", :tooltip true},\n :width 400,\n :background \"floralwhite\",\n :height 300,\n :data\n {:values\n  \"left,right,count\\n2.0,2.24,4\\n2.24,2.48,7\\n2.48,2.72,22\\n2.72,2.96,24\\n2.96,3.2,37\\n3.2,3.4400000000000004,31\\n3.4400000000000004,3.68,10\\n3.68,3.9200000000000004,11\\n3.9200000000000004,4.16,2\\n4.16,4.4,2\\n\",\n  :format {:type \"csv\"}}}\n\nThe resulting spec can be customized further:\n\n(-&gt; datasets/iris\n    (vis.stats/histogram :sepal-width\n                         {:nbins 10})\n    ;; varying the resulting vega-lite spec:\n    (assoc :height 125\n           :width 175))\n\n\n\n:bye\n\n\n:bye\n\n\nsource: notebooks/noj_book/statistical_visualization.clj",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Statistical Visualization (experimental üõ†)</span>"
    ]
  },
  {
    "objectID": "noj_book.more_visualization.html",
    "href": "noj_book.more_visualization.html",
    "title": "11¬† More visualization examples (experimental üõ†)",
    "section": "",
    "text": "11.1 Combining a few things together\nThe following is inspired by the example at Plotnine‚Äôs main page. Note how we add regression lines here. We take care of layout and colouring on our side, not using Vega-Lite for that.\nAlternatively, using a grouped dataset:\nA similar example with histograms:\nScatterplots and regression lines again, this time using Vega-Lite for layout and coloring (using its ‚Äúfacet‚Äù option).",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>More visualization examples (experimental üõ†)</span>"
    ]
  },
  {
    "objectID": "noj_book.more_visualization.html#combining-a-few-things-together",
    "href": "noj_book.more_visualization.html#combining-a-few-things-together",
    "title": "11¬† More visualization examples (experimental üõ†)",
    "section": "",
    "text": "(let [pallete (-&gt;&gt; :accent\n                   color/palette\n                   (mapv color/format-hex))]\n  (-&gt; datasets/mtcars\n      (tc/group-by :gear {:result-type :as-map})\n      (-&gt;&gt; (sort-by key)\n           (map-indexed\n            (fn [i [group-name ds]]\n              (-&gt; ds\n                  (vis.stats/linear-regression-plot\n                   :mpg :wt\n                   {:TITLE (str \"grear=\" group-name)\n                    :X :wt\n                    :MCOLOR (pallete i)\n                    :HEIGHT 200\n                    :WIDTH 200\n                    :point-options {:MSIZE 200}\n                    :line-options {:MSIZE 5}}))))\n           (vis.hanami/vconcat nil {}))))\n\n\n\n\n(let [pallete (-&gt;&gt; :accent\n                   color/palette\n                   (mapv color/format-hex))]\n  (-&gt; datasets/mtcars\n      (tc/map-columns :color [:gear] #(-&gt; % (- 3) pallete))\n      (tc/group-by [:gear])\n      (vis.stats/linear-regression-plot\n       :mpg :wt\n       {:X :wt\n        :MCOLOR {:expr \"datum.color\"}\n        :HEIGHT 200\n        :WIDTH 200\n        :point-options {:MSIZE 200}\n        :line-options {:MSIZE 5}})\n      (tc/order-by [:gear])))\n\n\n\n\n\n\n\n\n\n\n\ngear\nplot\n\n\n\n\n3\n\n\n\n\n\n4\n\n\n\n\n\n5\n\n\n\n\n\n\n\n\n\n\n\n(let [pallete (-&gt;&gt; :accent\n                   color/palette\n                   (mapv color/format-hex))]\n  (-&gt; datasets/iris\n      (tc/group-by :species {:result-type :as-map})\n      (-&gt;&gt; (sort-by key)\n           (map-indexed\n            (fn [i [group-name ds]]\n              (-&gt; ds\n                  (vis.stats/histogram :sepal-width\n                                       {:nbins 10}))))\n           (vis.hanami/vconcat nil {}))))\n\n\n\n\n(-&gt; datasets/mtcars\n    (tc/group-by [:gear])\n    (stats/add-predictions :mpg [:wt]\n                           {:model-type :smile.regression/ordinary-least-square})\n    (tc/ungroup)\n    (tc/select-columns [:gear :wt :mpg :mpg-prediction])\n    (vis.hanami/combined-plot\n     ht/layer-chart\n     {}\n     :LAYER [[ht/point-chart\n              {:X :wt\n               :Y :mpg\n               :MSIZE 200\n               :COLOR \"gear\"\n               :HEIGHT 100\n               :WIDTH 200}]\n             [ht/line-chart\n              {:X :wt\n               :Y :mpg-prediction\n               :MSIZE 5\n               :COLOR \"gear\"\n               :YTITLE :mpg}]])\n    ((fn [spec]\n       {:facet {:row {:field \"gear\"}}\n        :spec (dissoc spec :data)\n        :data (:data spec)}))\n    kind/vega-lite)\n\n\n\nsource: notebooks/noj_book/more_visualization.clj",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>More visualization examples (experimental üõ†)</span>"
    ]
  },
  {
    "objectID": "noj_book.visualizing_correlation_matrices.html",
    "href": "noj_book.visualizing_correlation_matrices.html",
    "title": "12¬† Visualizing correlation matrices (experimental üõ†) - DRAFT",
    "section": "",
    "text": "12.1 Auxiliary functions\nRounding numbers:\nFor example (see RoundingMode)",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Visualizing correlation matrices (experimental üõ†) - DRAFT</span>"
    ]
  },
  {
    "objectID": "noj_book.visualizing_correlation_matrices.html#auxiliary-functions",
    "href": "noj_book.visualizing_correlation_matrices.html#auxiliary-functions",
    "title": "12¬† Visualizing correlation matrices (experimental üõ†) - DRAFT",
    "section": "",
    "text": "(defn round\n  [n scale rm]\n  (.setScale ^java.math.BigDecimal (bigdec n)\n             (int scale)\n             ^RoundingMode (if (instance? java.math.RoundingMode rm)\n                             rm\n                             (java.math.RoundingMode/valueOf\n                              (str (if (ident? rm) (symbol rm) rm))))))\n\n\n\n(round (/ 2.0 3) 2 :DOWN)\n\n\n0.66M\n\n\n(round (/ 2.0 3) 2 :UP)\n\n\n0.67M\n\n\n(round (/ 2.0 3) 2 :HALF_EVEN)\n\n\n0.67M",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Visualizing correlation matrices (experimental üõ†) - DRAFT</span>"
    ]
  },
  {
    "objectID": "noj_book.visualizing_correlation_matrices.html#computing-a-correlation-matrix-and-representing-it-as-a-dataset",
    "href": "noj_book.visualizing_correlation_matrices.html#computing-a-correlation-matrix-and-representing-it-as-a-dataset",
    "title": "12¬† Visualizing correlation matrices (experimental üõ†) - DRAFT",
    "section": "12.2 Computing a correlation matrix and representing it as a dataset:",
    "text": "12.2 Computing a correlation matrix and representing it as a dataset:\n\n(defn correlations-dataset [data columns-to-use]\n  (let [matrix (-&gt;&gt; columns-to-use\n                    (mapv #(get data %))\n                    fastmath.stats/correlation-matrix)]\n    (-&gt;&gt; matrix\n         (map-indexed\n          (fn [i row]\n            (let [coli (columns-to-use i)]\n              (-&gt;&gt; row\n                   (map-indexed\n                    (fn [j corr]\n                      (let [colj (columns-to-use j)]\n                        {:i i\n                         :j j\n                         :coli coli\n                         :colj colj\n                         :corr corr\n                         :corr-round (round corr 2 :HALF_EVEN)})))))))\n         (apply concat)\n         tc/dataset)))\n\nFor example:\n\n(-&gt; noj-book.datasets/iris\n    (correlations-dataset [:sepal-length :sepal-width :petal-length :petal-width]))\n\n\n_unnamed [16 6]:\n\n\n\n:i\n:j\n:coli\n:colj\n:corr\n:corr-round\n\n\n\n\n0\n0\n:sepal-length\n:sepal-length\n1.00000000\n1.000\n\n\n0\n1\n:sepal-length\n:sepal-width\n-0.11756978\n-0.1200\n\n\n0\n2\n:sepal-length\n:petal-length\n0.87175378\n0.8700\n\n\n0\n3\n:sepal-length\n:petal-width\n0.81794113\n0.8200\n\n\n1\n0\n:sepal-width\n:sepal-length\n-0.11756978\n-0.1200\n\n\n1\n1\n:sepal-width\n:sepal-width\n1.00000000\n1.000\n\n\n1\n2\n:sepal-width\n:petal-length\n-0.42844010\n-0.4300\n\n\n1\n3\n:sepal-width\n:petal-width\n-0.36612593\n-0.3700\n\n\n2\n0\n:petal-length\n:sepal-length\n0.87175378\n0.8700\n\n\n2\n1\n:petal-length\n:sepal-width\n-0.42844010\n-0.4300\n\n\n2\n2\n:petal-length\n:petal-length\n1.00000000\n1.000\n\n\n2\n3\n:petal-length\n:petal-width\n0.96286543\n0.9600\n\n\n3\n0\n:petal-width\n:sepal-length\n0.81794113\n0.8200\n\n\n3\n1\n:petal-width\n:sepal-width\n-0.36612593\n-0.3700\n\n\n3\n2\n:petal-width\n:petal-length\n0.96286543\n0.9600\n\n\n3\n3\n:petal-width\n:petal-width\n1.00000000\n1.000",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Visualizing correlation matrices (experimental üõ†) - DRAFT</span>"
    ]
  },
  {
    "objectID": "noj_book.visualizing_correlation_matrices.html#drawing-a-heatmap-using-echarts",
    "href": "noj_book.visualizing_correlation_matrices.html#drawing-a-heatmap-using-echarts",
    "title": "12¬† Visualizing correlation matrices (experimental üõ†) - DRAFT",
    "section": "12.3 Drawing a heatmap using Echarts",
    "text": "12.3 Drawing a heatmap using Echarts\nThe following function is inspired by an Apache Echarts heatmap tutorial.\n\n(defn echarts-heatmap [{:keys [xyz-data xs ys\n                               min max\n                               series-name]\n                        :or {series-name \"\"}}]\n  (kind/echarts\n   {:tooltip {}\n    :xAxis {:type :category\n            :data xs}\n    :yAxis {:type :category\n            :data ys}\n    :visualMap {:min min\n                :max max\n                :calculable true\n                :splitNumber 8\n                :inRange {:color\n                          [\"#313695\" \"#4575b4\" \"#74add1\"\n                           \"#abd9e9\" \"#e0f3f8\" \"#ffffbf\"\n                           \"#fee090\" \"#fdae61\" \"#f46d43\"\n                           \"#d73027\" \"#a50026\"]}}\n    :series [{:name series-name\n              :type :heatmap\n              :data xyz-data\n              :itemStyle {:emphasis {:borderColor \"#333\"\n                                     :borderWidth 2}}\n              :progressive 1000\n              :animation false}]}))\n\nHere is an example using synthetic data:\n\n(let [n 30]\n  (echarts-heatmap\n   {:xyz-data (for [i (range n)\n                    j (range n)]\n                [i j (fastmath/logistic (*  (+ (- i j))\n                                            (rand)\n                                            (/ 2 (double n))))])\n    :x-data (range n)\n    :y-data (range n)\n    :min 0\n    :max 1}))\n\n\nNote the slider control and the tooltips.\nHere is an example with an actual correlation matrix.\n\n(let [columns-for-correlations [:sepal-length :sepal-width\n                                :petal-length :petal-width]\n      correlations (-&gt; noj-book.datasets/iris\n                       (correlations-dataset columns-for-correlations)\n                       (tc/select-columns [:coli :colj :corr-round])\n                       tc/rows)]\n  (echarts-heatmap {:xyz-data correlations\n                    :xs columns-for-correlations\n                    :ys columns-for-correlations\n                    :min -1\n                    :max 1\n                    :series-name \"correlation\"}))\n\n\nTODO: Improve the layout so that the slider control does not overlap the labels.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Visualizing correlation matrices (experimental üõ†) - DRAFT</span>"
    ]
  },
  {
    "objectID": "noj_book.visualizing_correlation_matrices.html#drawing-a-heatmap-using-cljplot",
    "href": "noj_book.visualizing_correlation_matrices.html#drawing-a-heatmap-using-cljplot",
    "title": "12¬† Visualizing correlation matrices (experimental üõ†) - DRAFT",
    "section": "12.4 Drawing a heatmap using cljplot",
    "text": "12.4 Drawing a heatmap using cljplot\ncoming soon",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Visualizing correlation matrices (experimental üõ†) - DRAFT</span>"
    ]
  },
  {
    "objectID": "noj_book.visualizing_correlation_matrices.html#drawing-a-heatmap-using-vega",
    "href": "noj_book.visualizing_correlation_matrices.html#drawing-a-heatmap-using-vega",
    "title": "12¬† Visualizing correlation matrices (experimental üõ†) - DRAFT",
    "section": "12.5 Drawing a heatmap using Vega",
    "text": "12.5 Drawing a heatmap using Vega\ncoming soon\n\nsource: notebooks/noj_book/visualizing_correlation_matrices.clj",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Visualizing correlation matrices (experimental üõ†) - DRAFT</span>"
    ]
  }
]