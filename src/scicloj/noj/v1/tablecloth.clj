(ns scicloj.noj.v1.tablecloth
  ;;Autogenerated from scicloj.noj.v1.lifted-tc-- DO NOT EDIT
  ""
  (:require [scicloj.noj.v1.lifted-tc]))

(defn ->array
  "Convert numerical column(s) to java array"
  ([ds-or-ctx colname]
   (scicloj.noj.v1.lifted-tc/->array ds-or-ctx colname))
  ([ds-or-ctx colname datatype]
   (scicloj.noj.v1.lifted-tc/->array ds-or-ctx colname datatype)))


(defn add-column
  "Add or update (modify) column under `column-name`.

  `column` can be sequence of values or generator function (which gets `ds` as input).

  * `ds` - a dataset
  * `column-name` - if it's existing column name, column will be replaced
  * `column` - can be column (from other dataset), sequence, single value or function (taking a dataset). Too big columns are always trimmed. Too small are cycled or extended with missing values (according to `size-strategy` argument)
  * `size-strategy` (optional) - when new column is shorter than dataset row count, following strategies are applied:
    - `:cycle` - repeat data
    - `:na` - append missing values
    - `:strict` - (default) throws an exception when sizes mismatch"
  ([ds-or-ctx column-name column]
   (scicloj.noj.v1.lifted-tc/add-column ds-or-ctx column-name column))
  ([ds-or-ctx column-name column size-strategy]
   (scicloj.noj.v1.lifted-tc/add-column ds-or-ctx column-name column size-strategy)))


(defn add-columns
  "Add or updade (modify) columns defined in `columns-map` (mapping: name -> column) "
  ([ds-or-ctx columns-map]
   (scicloj.noj.v1.lifted-tc/add-columns ds-or-ctx columns-map))
  ([ds-or-ctx columns-map size-strategy]
   (scicloj.noj.v1.lifted-tc/add-columns ds-or-ctx columns-map size-strategy)))


(defn add-or-replace-column
  ([ds-or-ctx column-name column]
   (scicloj.noj.v1.lifted-tc/add-or-replace-column ds-or-ctx column-name column))
  ([ds-or-ctx column-name column size-strategy]
   (scicloj.noj.v1.lifted-tc/add-or-replace-column ds-or-ctx column-name column size-strategy)))


(defn add-or-replace-columns
  ([ds-or-ctx columns-map]
   (scicloj.noj.v1.lifted-tc/add-or-replace-columns ds-or-ctx columns-map))
  ([ds-or-ctx columns-map size-strategy]
   (scicloj.noj.v1.lifted-tc/add-or-replace-columns ds-or-ctx columns-map size-strategy)))


(defn aggregate
  "Aggregate dataset by providing:

  - aggregation function
  - map with column names and functions
  - sequence of aggregation functions

  Aggregation functions can return:
  - single value
  - seq of values
  - map of values with column names"
  ([ds-or-ctx aggregator]
   (scicloj.noj.v1.lifted-tc/aggregate ds-or-ctx aggregator))
  ([ds-or-ctx aggregator options]
   (scicloj.noj.v1.lifted-tc/aggregate ds-or-ctx aggregator options)))


(defn aggregate-columns
  "Aggregates each column separately"
  ([ds-or-ctx columns-aggregators]
   (scicloj.noj.v1.lifted-tc/aggregate-columns ds-or-ctx columns-aggregators))
  ([ds-or-ctx columns-selector column-aggregators]
   (scicloj.noj.v1.lifted-tc/aggregate-columns ds-or-ctx columns-selector column-aggregators))
  ([ds-or-ctx columns-selector column-aggregators options]
   (scicloj.noj.v1.lifted-tc/aggregate-columns ds-or-ctx columns-selector column-aggregators options)))


(defn anti-join
  ([ds-left ds-right columns-selector]
   (scicloj.noj.v1.lifted-tc/anti-join ds-left ds-right columns-selector))
  ([ds-left ds-right columns-selector options]
   (scicloj.noj.v1.lifted-tc/anti-join ds-left ds-right columns-selector options)))


(defn append
  "Concats columns of several datasets"
  ([ds-or-ctx & args]
   (apply scicloj.noj.v1.lifted-tc/append ds-or-ctx args)))


(defn array-column->columns
  "Converts a column of type java array into several columns,
  one for each element of the array of all rows. The source column is dropped afterwards.
  The function assumes that arrays in all rows have same type and length and are numeric.

  `ds` Datset to operate on.
  `src-column` The (array) column to convert
  `opts` can contain:
    `prefix` newly created column will get prefix before column number
  "
  ([ds-or-ctx src-column opts]
   (scicloj.noj.v1.lifted-tc/array-column->columns ds-or-ctx src-column opts))
  ([ds-or-ctx src-column]
   (scicloj.noj.v1.lifted-tc/array-column->columns ds-or-ctx src-column)))


(defn as-regular-dataset
  "Remove grouping tag"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/as-regular-dataset ds-or-ctx)))


(defn asof-join
  ([ds-left ds-right columns-selector]
   (scicloj.noj.v1.lifted-tc/asof-join ds-left ds-right columns-selector))
  ([ds-left ds-right columns-selector options]
   (scicloj.noj.v1.lifted-tc/asof-join ds-left ds-right columns-selector options)))


(defn bind
  ([ds-or-ctx & args]
   (apply scicloj.noj.v1.lifted-tc/bind ds-or-ctx args)))


(defn by-rank
  "Select rows using `rank` on a column, ties are resolved using `:dense` method.

  See [R docs](https://www.rdocumentation.org/packages/base/versions/3.6.1/topics/rank).
  Rank uses 0 based indexing.
  
  Possible `:ties` strategies: `:average`, `:first`, `:last`, `:random`, `:min`, `:max`, `:dense`.
  `:dense` is the same as in `data.table::frank` from R

  `:desc?` set to true (default) order descending before calculating rank"
  ([ds-or-ctx columns-selector rank-predicate]
   (scicloj.noj.v1.lifted-tc/by-rank ds-or-ctx columns-selector rank-predicate))
  ([ds-or-ctx columns-selector rank-predicate options]
   (scicloj.noj.v1.lifted-tc/by-rank ds-or-ctx columns-selector rank-predicate options)))


(defn clone
  "Clone an object.  Can clone anything convertible to a reader."
  ([item]
   (scicloj.noj.v1.lifted-tc/clone item)))


(defn column
  ([dataset colname]
   (scicloj.noj.v1.lifted-tc/column dataset colname)))


(defn column-count
  ([dataset]
   (scicloj.noj.v1.lifted-tc/column-count dataset)))


(defn column-names
  "Returns column names, given a selector.
  Columns-selector can be one of the following:

  * :all keyword - selects all columns
  * column name - for single column
  * sequence of column names - for collection of columns
  * regex - to apply pattern on column names or datatype
  * filter predicate - to filter column names or datatype
  * type namespaced keyword for specific datatype or group of datatypes

  Column name can be anything.

column-names function returns names according to columns-selector
  and optional meta-field. meta-field is one of the following:

  * `:name` (default) - to operate on column names
  * `:datatype` - to operated on column types
  * `:all` - if you want to process all metadata

  Datatype groups are:

  * `:type/numerical` - any numerical type
  * `:type/float` - floating point number (:float32 and :float64)
  * `:type/integer` - any integer
  * `:type/datetime` - any datetime type

  If qualified keyword starts with :!type, complement set is used.


  "
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/column-names ds-or-ctx))
  ([ds-or-ctx columns-selector]
   (scicloj.noj.v1.lifted-tc/column-names ds-or-ctx columns-selector))
  ([ds-or-ctx columns-selector meta-field]
   (scicloj.noj.v1.lifted-tc/column-names ds-or-ctx columns-selector meta-field)))


(defn columns
  "Returns columns of dataset. Result type can be any of:
  * `:as-map`
  * `:as-double-arrays`
  * `:as-seqs`
  "
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/columns ds-or-ctx))
  ([ds-or-ctx result-type]
   (scicloj.noj.v1.lifted-tc/columns ds-or-ctx result-type)))


(defn columns->array-column
  "Converts several columns to a single column of type array.
   The src columns are dropped afterwards.

  `ds` Dataset to operate on.
  `column-selector` anything supported by [[select-columns]]
  `new-column` new column to create
  "
  ([ds-or-ctx column-selector new-column]
   (scicloj.noj.v1.lifted-tc/columns->array-column ds-or-ctx column-selector new-column)))


(defn complete
  "TidyR complete.

  Fills a dataset with all possible combinations of selected columns. When a given combination doesn't exist, missing values are created."
  ([ds-or-ctx columns-selector & args]
   (apply scicloj.noj.v1.lifted-tc/complete ds-or-ctx columns-selector args)))


(defn concat
  "Joins rows from other datasets"
  ([dataset & args]
   (apply scicloj.noj.v1.lifted-tc/concat dataset args)))


(defn concat-copying
  "Joins rows from other datasets via a copy of data"
  ([dataset & args]
   (apply scicloj.noj.v1.lifted-tc/concat-copying dataset args)))


(defn convert-types
  "Convert type of the column to the other type."
  ([ds-or-ctx coltype-map-or-columns-selector]
   (scicloj.noj.v1.lifted-tc/convert-types ds-or-ctx coltype-map-or-columns-selector))
  ([ds-or-ctx columns-selector new-types]
   (scicloj.noj.v1.lifted-tc/convert-types ds-or-ctx columns-selector new-types)))


(defn cross-join
  "Cross product from selected columns"
  ([ds-left ds-right]
   (scicloj.noj.v1.lifted-tc/cross-join ds-left ds-right))
  ([ds-left ds-right columns-selector]
   (scicloj.noj.v1.lifted-tc/cross-join ds-left ds-right columns-selector))
  ([ds-left ds-right columns-selector options]
   (scicloj.noj.v1.lifted-tc/cross-join ds-left ds-right columns-selector options)))


(defn crosstab
  "Cross tabulation of two sets of columns.

  Creates grouped dataset by [row-selector, col-selector] pairs and calls aggregation on each group.

  Options:

  * pivot? - create pivot table or just flat structure (default: true)
  * replace-missing? - replace missing values? (default: true)
  * missing-value - a missing value (default: 0)
  * aggregator - aggregating function (default: row-count)
  * marginal-rows, marginal-cols - adds row and/or cols, it's a sum if true. Can be a custom fn."
  ([ds-or-ctx row-selector col-selector]
   (scicloj.noj.v1.lifted-tc/crosstab ds-or-ctx row-selector col-selector))
  ([ds-or-ctx row-selector col-selector options]
   (scicloj.noj.v1.lifted-tc/crosstab ds-or-ctx row-selector col-selector options)))


(defn dataset
  "Create a `dataset`.
  
  Dataset can be created from:

  * map of values and/or sequences
  * sequence of maps
  * sequence of columns
  * file or url
  * array of arrays
  * single value

  Single value is set only when it's not possible to find a path for given data. If tech.ml.dataset throws an exception, it's won;t be printed. To print a stack trace, set `stack-trace?` option to `true`.

  ds/->dataset documentation:

  Create a dataset from either csv/tsv or a sequence of maps.

   * A `String` be interpreted as a file (or gzipped file if it
     ends with .gz) of tsv or csv data.  The system will attempt to autodetect if this
     is csv or tsv and then engineering around detecting datatypes all of which can
     be overridden.

  * InputStreams have no file type and thus a `file-type` must be provided in the
    options.

  * A sequence of maps may be passed in in which case the first N maps are scanned in
    order to derive the column datatypes before the actual columns are created.

  Parquet, xlsx, and xls formats require that you require the appropriate libraries
  which are `tech.v3.libs.parquet` for parquet, `tech.v3.libs.fastexcel` for xlsx,
  and `tech.v3.libs.poi` for xls.


  Arrow support is provided via the tech.v3.libs.Arrow namespace not via a file-type
  overload as the Arrow project current has 3 different file types and it is not clear
  what their final suffix will be or which of the three file types it will indicate.
  Please see documentation in the `tech.v3.libs.arrow` namespace for further information
  on Arrow file types.

  Options:

  - `:dataset-name` - set the name of the dataset.
  - `:file-type` - Override filetype discovery mechanism for strings or force a particular
      parser for an input stream.  Note that parquet must have paths on disk
      and cannot currently load from input stream.  Acceptible file types are:
      #{:csv :tsv :xlsx :xls :parquet}.
  - `:gzipped?` - for file formats that support it, override autodetection and force
     creation of a gzipped input stream as opposed to a normal input stream.
  - `:column-allowlist` - either sequence of string column names or sequence of column
     indices of columns to allowlist. This is preferred to `:column-whitelist`
  - `:column-blocklist` - either sequence of string column names or sequence of column
     indices of columns to blocklist. This is preferred to `:column-blacklist`
  - `:num-rows` - Number of rows to read
  - `:header-row?` - Defaults to true, indicates the first row is a header.
  - `:key-fn` - function to be applied to column names.  Typical use is:
     `:key-fn keyword`.
  - `:separator` - Add a character separator to the list of separators to auto-detect.
  - `:csv-parser` - Implementation of univocity's AbstractParser to use.  If not
     provided a default permissive parser is used.  This way you parse anything that
     univocity supports (so flat files and such).
  - `:bad-row-policy` - One of three options: :skip, :error, :carry-on.  Defaults to
     :carry-on.  Some csv data has ragged rows and in this case we have several
     options. If the option is :carry-on then we either create a new column or add
     missing values for columns that had no data for that row.
  - `:skip-bad-rows?` - Legacy option.  Use :bad-row-policy.
  - `:disable-comment-skipping?` - As default, the `#` character is recognised as a
     line comment when found in the beginning of a line of text in a CSV file,
     and the row will be ignored. Set `true` to disable this behavior.
  - `:max-chars-per-column` - Defaults to 4096.  Columns with more characters that this
     will result in an exception.
  - `:max-num-columns` - Defaults to 8192.  CSV,TSV files with more columns than this
     will fail to parse.  For more information on this option, please visit:
     https://github.com/uniVocity/univocity-parsers/issues/301
  - `:text-temp-dir` - The temporary directory to use for file-backed text.  Setting
    this value to boolean 'false' turns off file backed text which is the default.  If a
    tech.v3.resource stack context is opened the file will be deleted when the context
    closes else it will be deleted when the gc cleans up the dataset.  A shutdown hook is
    added as a last resort to ensure the file is cleaned up.
  - `:n-initial-skip-rows` - Skip N rows initially.  This currently may include the
     header row.  Works across both csv and spreadsheet datasets.
  - `:parser-type` - Default parser to use if no parser-fn is specified for that column.
     For csv files, the default parser type is `:string` which indicates a promotional
     string parser.  For sequences of maps, the default parser type is :object.  It can
     be useful in some contexts to use the `:string` parser with sequences of maps or
     maps of columns.
  - `:parser-fn` -
      - `keyword?` - all columns parsed to this datatype. For example:
        `{:parser-fn :string}`
      - `map?` - `{column-name parse-method}` parse each column with specified
        `parse-method`.
        The `parse-method` can be:
          - `keyword?` - parse the specified column to this datatype. For example:
            `{:parser-fn {:answer :boolean :id :int32}}`
          - tuple - pair of `[datatype parse-data]` in which case container of type
            `[datatype]` will be created. `parse-data` can be one of:
              - `:relaxed?` - data will be parsed such that parse failures of the standard
                 parse functions do not stop the parsing process.  :unparsed-values and
                 :unparsed-indexes are available in the metadata of the column that tell
                 you the values that failed to parse and their respective indexes.
              - `fn?` - function from str-> one of `:tech.v3.dataset/missing`,
                 `:tech.v3.dataset/parse-failure`, or the parsed value.
                 Exceptions here always kill the parse process.  :missing will get marked
                 in the missing indexes, and :parse-failure will result in the index being
                 added to missing, the unparsed the column's :unparsed-values and
                 :unparsed-indexes will be updated.
              - `string?` - for datetime types, this will turned into a DateTimeFormatter via
                 DateTimeFormatter/ofPattern.  For `:text` you can specify the backing file
                 to use.
              - `DateTimeFormatter` - use with the appropriate temporal parse static function
                 to parse the value.

   - `map?` - the header-name-or-idx is used to lookup value.  If not nil, then
           value can be any of the above options.  Else the default column parser
           is used.

  Returns a new dataset"
  ([]
   (scicloj.noj.v1.lifted-tc/dataset))
  ([data]
   (scicloj.noj.v1.lifted-tc/dataset data))
  ([data options]
   (scicloj.noj.v1.lifted-tc/dataset data options)))


(defn dataset->str
  "Convert a dataset to a string.  Prints a single line header and then calls
  dataset-data->str.

  For options documentation see dataset-data->str."
  ([ds-or-ctx options]
   (scicloj.noj.v1.lifted-tc/dataset->str ds-or-ctx options))
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/dataset->str ds-or-ctx)))


(defn dataset-name
  ([dataset]
   (scicloj.noj.v1.lifted-tc/dataset-name dataset)))


(defn dataset?
  "Is `ds` a `dataset` type?"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/dataset? ds-or-ctx)))


(defn difference
  ([ds-left ds-right]
   (scicloj.noj.v1.lifted-tc/difference ds-left ds-right))
  ([ds-left ds-right options]
   (scicloj.noj.v1.lifted-tc/difference ds-left ds-right options)))


(defn drop
  "Drop columns and rows."
  ([ds-or-ctx columns-selector rows-selector]
   (scicloj.noj.v1.lifted-tc/drop ds-or-ctx columns-selector rows-selector)))


(defn drop-columns
  "Drop columns by (returns dataset):

  - name
  - sequence of names
  - map of names with new names (rename)
  - function which filter names (via column metadata)"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/drop-columns ds-or-ctx))
  ([ds-or-ctx columns-selector]
   (scicloj.noj.v1.lifted-tc/drop-columns ds-or-ctx columns-selector))
  ([ds-or-ctx columns-selector meta-field]
   (scicloj.noj.v1.lifted-tc/drop-columns ds-or-ctx columns-selector meta-field)))


(defn drop-missing
  "Drop rows with missing values

 `columns-selector` selects columns to look at missing values"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/drop-missing ds-or-ctx))
  ([ds-or-ctx columns-selector]
   (scicloj.noj.v1.lifted-tc/drop-missing ds-or-ctx columns-selector)))


(defn drop-rows
  "Drop rows using:

  - row id
  - seq of row ids
  - seq of true/false
  - fn with predicate"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/drop-rows ds-or-ctx))
  ([ds-or-ctx rows-selector]
   (scicloj.noj.v1.lifted-tc/drop-rows ds-or-ctx rows-selector))
  ([ds-or-ctx rows-selector options]
   (scicloj.noj.v1.lifted-tc/drop-rows ds-or-ctx rows-selector options)))


(defn empty-ds?
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/empty-ds? ds-or-ctx)))


(defn expand
  "TidyR expand.

  Creates all possible combinations of selected columns."
  ([ds-or-ctx columns-selector & args]
   (apply scicloj.noj.v1.lifted-tc/expand ds-or-ctx columns-selector args)))


(defn fill-range-replace
  "Fill missing up with lacking values. Accepts
  * dataset
  * column name
  * expected step (max-span, milliseconds in case of datetime column)
  * (optional) missing-strategy - how to replace missing, default :down (set to nil if none)
  * (optional) missing-value - optional value for replace missing
"
  ([ds-or-ctx colname max-span]
   (scicloj.noj.v1.lifted-tc/fill-range-replace ds-or-ctx colname max-span))
  ([ds-or-ctx colname max-span missing-strategy]
   (scicloj.noj.v1.lifted-tc/fill-range-replace ds-or-ctx colname max-span missing-strategy))
  ([ds-or-ctx colname max-span missing-strategy missing-value]
   (scicloj.noj.v1.lifted-tc/fill-range-replace ds-or-ctx colname max-span missing-strategy missing-value)))


(defn first
  "First row"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/first ds-or-ctx)))


(defn fold-by
  "Group-by and pack columns into vector - the output data set has a row for each unique combination
  of the provided columns while each remaining column has its valu(es) collected into a vector, similar
  to how clojure.core/group-by works.
  See https://scicloj.github.io/tablecloth/index.html#Fold-by"
  ([ds-or-ctx columns-selector]
   (scicloj.noj.v1.lifted-tc/fold-by ds-or-ctx columns-selector))
  ([ds-or-ctx columns-selector folding-function]
   (scicloj.noj.v1.lifted-tc/fold-by ds-or-ctx columns-selector folding-function)))


(defn full-join
  "Join keeping all rows"
  ([ds-left ds-right columns-selector]
   (scicloj.noj.v1.lifted-tc/full-join ds-left ds-right columns-selector))
  ([ds-left ds-right columns-selector options]
   (scicloj.noj.v1.lifted-tc/full-join ds-left ds-right columns-selector options)))


(defn get-entry
  "Returns a single value from given column and row"
  ([ds-or-ctx column row]
   (scicloj.noj.v1.lifted-tc/get-entry ds-or-ctx column row)))


(defn group-by
  "Group dataset by:

  - column name
  - list of columns
  - map of keys and row indexes
  - function getting map of values

  Options are:

  - select-keys - when grouping is done by function, you can limit fields to a `select-keys` seq.
  - result-type - return results as dataset (`:as-dataset`, default) or as map of datasets (`:as-map`) or as map of row indexes (`:as-indexes`) or as sequence of (sub)datasets
  - other parameters which are passed to `dataset` fn

  When dataset is returned, meta contains `:grouped?` set to true. Columns in dataset:

  - name - group name
  - group-id - id of the group (int)
  - data - group as dataset"
  ([ds-or-ctx grouping-selector]
   (scicloj.noj.v1.lifted-tc/group-by ds-or-ctx grouping-selector))
  ([ds-or-ctx grouping-selector options]
   (scicloj.noj.v1.lifted-tc/group-by ds-or-ctx grouping-selector options)))


(defn grouped?
  "Is `dataset` represents grouped dataset (result of `group-by`)?"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/grouped? ds-or-ctx)))


(defn groups->map
  "Convert grouped dataset to the map of groups"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/groups->map ds-or-ctx)))


(defn groups->seq
  "Convert grouped dataset to seq of the groups"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/groups->seq ds-or-ctx)))


(defn has-column?
  ([dataset column-name]
   (scicloj.noj.v1.lifted-tc/has-column? dataset column-name)))


(defn head
  "First n rows (default 5)"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/head ds-or-ctx))
  ([ds-or-ctx n]
   (scicloj.noj.v1.lifted-tc/head ds-or-ctx n)))


(defn info
  "Returns a statistcial information about the columns of a dataset.
  `result-type ` can be :descriptive or :columns"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/info ds-or-ctx))
  ([ds-or-ctx result-type]
   (scicloj.noj.v1.lifted-tc/info ds-or-ctx result-type)))


(defn inner-join
  ([ds-left ds-right columns-selector]
   (scicloj.noj.v1.lifted-tc/inner-join ds-left ds-right columns-selector))
  ([ds-left ds-right columns-selector options]
   (scicloj.noj.v1.lifted-tc/inner-join ds-left ds-right columns-selector options)))


(defn intersect
  ([ds-left ds-right]
   (scicloj.noj.v1.lifted-tc/intersect ds-left ds-right))
  ([ds-left ds-right options]
   (scicloj.noj.v1.lifted-tc/intersect ds-left ds-right options)))


(defn join-columns
  "Join clumns of dataset. Accepts:
  dataset
  column selector (as in select-columns)
  options
  `:separator` (default \"-\")
  `:drop-columns?` - whether to drop source columns or not (default true)
  `:result-type`
     `:map` - packs data into map
     `:seq` - packs data into sequence
     `:string` - join strings with separator (default)
     or custom function which gets row as a vector
  `:missing-subst` - substitution for missing value"
  ([ds-or-ctx target-column columns-selector]
   (scicloj.noj.v1.lifted-tc/join-columns ds-or-ctx target-column columns-selector))
  ([ds-or-ctx target-column columns-selector conf]
   (scicloj.noj.v1.lifted-tc/join-columns ds-or-ctx target-column columns-selector conf)))


(defn last
  "Last row"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/last ds-or-ctx)))


(defn left-join
  ([ds-left ds-right columns-selector]
   (scicloj.noj.v1.lifted-tc/left-join ds-left ds-right columns-selector))
  ([ds-left ds-right columns-selector options]
   (scicloj.noj.v1.lifted-tc/left-join ds-left ds-right columns-selector options)))


(defmacro let-dataset
  ([bindings]
   `(scicloj.noj.v1.lifted-tc/let-dataset ~bindings))
  ([bindings options]
   `(scicloj.noj.v1.lifted-tc/let-dataset ~bindings ~options)))


(defn map-columns
  "Map over rows using a map function. The arity should match the columns selected."
  ([ds-or-ctx column-name map-fn]
   (scicloj.noj.v1.lifted-tc/map-columns ds-or-ctx column-name map-fn))
  ([ds-or-ctx column-name columns-selector map-fn]
   (scicloj.noj.v1.lifted-tc/map-columns ds-or-ctx column-name columns-selector map-fn))
  ([ds-or-ctx column-name new-type columns-selector map-fn]
   (scicloj.noj.v1.lifted-tc/map-columns ds-or-ctx column-name new-type columns-selector map-fn)))


(defn map-rows
  "Map a function across the rows of the dataset producing a new dataset that is merged back into the original potentially replacing existing columns."
  ([ds-or-ctx map-fn]
   (scicloj.noj.v1.lifted-tc/map-rows ds-or-ctx map-fn))
  ([ds-or-ctx map-fn options]
   (scicloj.noj.v1.lifted-tc/map-rows ds-or-ctx map-fn options)))


(defn mark-as-group
  "Add grouping tag"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/mark-as-group ds-or-ctx)))


(defn order-by
  "Order dataset by:
  - column name
  - columns (as sequence of names)
  - key-fn
  - sequence of columns / key-fn
  Additionally you can ask the order by:
  - :asc
  - :desc
  - custom comparator function"
  ([ds-or-ctx columns-or-fn]
   (scicloj.noj.v1.lifted-tc/order-by ds-or-ctx columns-or-fn))
  ([ds-or-ctx columns-or-fn comparators]
   (scicloj.noj.v1.lifted-tc/order-by ds-or-ctx columns-or-fn comparators))
  ([ds-or-ctx columns-or-fn comparators options]
   (scicloj.noj.v1.lifted-tc/order-by ds-or-ctx columns-or-fn comparators options)))


(defn pivot->longer
  "`tidyr` pivot_longer api"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/pivot->longer ds-or-ctx))
  ([ds-or-ctx columns-selector]
   (scicloj.noj.v1.lifted-tc/pivot->longer ds-or-ctx columns-selector))
  ([ds-or-ctx columns-selector options]
   (scicloj.noj.v1.lifted-tc/pivot->longer ds-or-ctx columns-selector options)))


(defn pivot->wider
  "Converts columns to rows. Arguments:
  * dataset
  * columns selector
  * options:
    `:target-columns` - names of the columns created or columns pattern (see below) (default: :$column)
    `:value-column-name` - name of the column for values (default: :$value)
    `:splitter` - string, regular expression or function which splits source column names into data
    `:drop-missing?` - remove rows with missing? (default: true)
    `:datatypes` - map of target columns data types
    `:coerce-to-number` - try to convert extracted values to numbers if possible (default: true)

  * target-columns - can be:

    * column name - source columns names are put there as a data
    * column names as seqence - source columns names after split are put separately into :target-columns as data
    * pattern - is a sequence of names, where some of the names are nil. nil is replaced by a name taken from splitter and such column is used for values.
  "
  ([ds-or-ctx columns-selector value-columns]
   (scicloj.noj.v1.lifted-tc/pivot->wider ds-or-ctx columns-selector value-columns))
  ([ds-or-ctx columns-selector value-columns options]
   (scicloj.noj.v1.lifted-tc/pivot->wider ds-or-ctx columns-selector value-columns options)))


(defn print-dataset
  "Prints dataset into console. For options see
  tech.v3.dataset.print/dataset-data->str"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/print-dataset ds-or-ctx))
  ([ds-or-ctx options]
   (scicloj.noj.v1.lifted-tc/print-dataset ds-or-ctx options)))


(defn process-group-data
  "Internal: The passed-in function is applied on all groups"
  ([ds-or-ctx f]
   (scicloj.noj.v1.lifted-tc/process-group-data ds-or-ctx f))
  ([ds-or-ctx f parallel?]
   (scicloj.noj.v1.lifted-tc/process-group-data ds-or-ctx f parallel?)))


(defn rand-nth
  "Returns single random row"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/rand-nth ds-or-ctx))
  ([ds-or-ctx options]
   (scicloj.noj.v1.lifted-tc/rand-nth ds-or-ctx options)))


(defn random
  "Returns (n) random rows with repetition"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/random ds-or-ctx))
  ([ds-or-ctx n]
   (scicloj.noj.v1.lifted-tc/random ds-or-ctx n))
  ([ds-or-ctx n options]
   (scicloj.noj.v1.lifted-tc/random ds-or-ctx n options)))


(defn read-nippy
  ([filename]
   (scicloj.noj.v1.lifted-tc/read-nippy filename)))


(defn rename-columns
  "Rename columns with provided old -> new name map"
  ([ds-or-ctx columns-selector columns-map-fn]
   (scicloj.noj.v1.lifted-tc/rename-columns ds-or-ctx columns-selector columns-map-fn))
  ([ds-or-ctx columns-mapping]
   (scicloj.noj.v1.lifted-tc/rename-columns ds-or-ctx columns-mapping)))


(defn reorder-columns
  "Reorder columns using column selector(s). When column names are incomplete, the missing will be attached at the end."
  ([ds-or-ctx columns-selector & args]
   (apply scicloj.noj.v1.lifted-tc/reorder-columns ds-or-ctx columns-selector args)))


(defn replace-missing
  "Replaces missing values. Accepts

  * dataset
  * column selector, default: :all
  * strategy, default: :nearest
  * value (optional)
  * single value
  * sequence of values (cycled)
  * function, applied on column(s) with stripped missings

  Strategies are:

  `:value` - replace with given value
  `:up` - copy values up
  `:down` - copy values down
  `:updown` - copy values up and then down for missing values at the end
  `:downup` - copy values down and then up for missing values at the beginning
  `:mid` or `:nearest` - copy values around known values
  `:midpoint` - use average value from previous and next non-missing
  `:lerp` - trying to lineary approximate values, works for numbers and datetime, otherwise applies :nearest. For numbers always results in float datatype.
  "
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/replace-missing ds-or-ctx))
  ([ds-or-ctx strategy]
   (scicloj.noj.v1.lifted-tc/replace-missing ds-or-ctx strategy))
  ([ds-or-ctx columns-selector strategy]
   (scicloj.noj.v1.lifted-tc/replace-missing ds-or-ctx columns-selector strategy))
  ([ds-or-ctx columns-selector strategy value]
   (scicloj.noj.v1.lifted-tc/replace-missing ds-or-ctx columns-selector strategy value)))


(defn right-join
  ([ds-left ds-right columns-selector]
   (scicloj.noj.v1.lifted-tc/right-join ds-left ds-right columns-selector))
  ([ds-left ds-right columns-selector options]
   (scicloj.noj.v1.lifted-tc/right-join ds-left ds-right columns-selector options)))


(defn row-count
  ([dataset-or-col]
   (scicloj.noj.v1.lifted-tc/row-count dataset-or-col)))


(defn rows
  "Returns rows of dataset. Result type can be any of:
  * `:as-maps` - maps
  * `:as-double-arrays` - double arrays
  * `:as-seqs` - reader (sequence, default)
  * `:as-vecs` - vectors

  If you want to elide nils in maps set `:nil-missing?` option to false (default: `true`).
  Another option - `:copying?` - when true row values are copied on read (default: `false`)."
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/rows ds-or-ctx))
  ([ds-or-ctx result-type]
   (scicloj.noj.v1.lifted-tc/rows ds-or-ctx result-type))
  ([ds-or-ctx result-type options]
   (scicloj.noj.v1.lifted-tc/rows ds-or-ctx result-type options)))


(defn select
  "Select columns and rows."
  ([ds-or-ctx columns-selector rows-selector]
   (scicloj.noj.v1.lifted-tc/select ds-or-ctx columns-selector rows-selector)))


(defn select-columns
  "Select columns by (returns dataset):

  - name
  - sequence of names
  - map of names with new names (rename)
  - function which filter names (via column metadata)"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/select-columns ds-or-ctx))
  ([ds-or-ctx columns-selector]
   (scicloj.noj.v1.lifted-tc/select-columns ds-or-ctx columns-selector))
  ([ds-or-ctx columns-selector meta-field]
   (scicloj.noj.v1.lifted-tc/select-columns ds-or-ctx columns-selector meta-field)))


(defn select-missing
  "Select rows with missing values

 `columns-selector` selects columns to look at missing values"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/select-missing ds-or-ctx))
  ([ds-or-ctx columns-selector]
   (scicloj.noj.v1.lifted-tc/select-missing ds-or-ctx columns-selector)))


(defn select-rows
  "Select rows using:

  - row id
  - seq of row ids
  - seq of true/false
  - fn with predicate"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/select-rows ds-or-ctx))
  ([ds-or-ctx rows-selector]
   (scicloj.noj.v1.lifted-tc/select-rows ds-or-ctx rows-selector))
  ([ds-or-ctx rows-selector options]
   (scicloj.noj.v1.lifted-tc/select-rows ds-or-ctx rows-selector options)))


(defn semi-join
  ([ds-left ds-right columns-selector]
   (scicloj.noj.v1.lifted-tc/semi-join ds-left ds-right columns-selector))
  ([ds-left ds-right columns-selector options]
   (scicloj.noj.v1.lifted-tc/semi-join ds-left ds-right columns-selector options)))


(defn separate-column
  ([ds-or-ctx column]
   (scicloj.noj.v1.lifted-tc/separate-column ds-or-ctx column))
  ([ds-or-ctx column separator]
   (scicloj.noj.v1.lifted-tc/separate-column ds-or-ctx column separator))
  ([ds-or-ctx column target-columns separator]
   (scicloj.noj.v1.lifted-tc/separate-column ds-or-ctx column target-columns separator))
  ([ds-or-ctx column target-columns separator conf]
   (scicloj.noj.v1.lifted-tc/separate-column ds-or-ctx column target-columns separator conf)))


(defn set-dataset-name
  ([dataset ds-name]
   (scicloj.noj.v1.lifted-tc/set-dataset-name dataset ds-name)))


(defn shape
  "Returns shape of the dataset [rows, cols]"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/shape ds-or-ctx)))


(defn shuffle
  "Shuffle dataset (with seed)"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/shuffle ds-or-ctx))
  ([ds-or-ctx options]
   (scicloj.noj.v1.lifted-tc/shuffle ds-or-ctx options)))


(defn split
  "Split given dataset into 2 or more (holdout) splits

  As the result two new columns are added:

  * `:$split-name` - with subgroup name
  * `:$split-id` - fold id/repetition id

  `split-type` can be one of the following:

  * `:kfold` - k-fold strategy, `:k` defines number of folds (defaults to `5`), produces `k` splits
  * `:bootstrap` - `:ratio` defines ratio of observations put into result (defaults to `1.0`), produces `1` split
  * `:holdout` - split into two parts with given ratio (defaults to `2/3`), produces `1` split
  * `:loo` - leave one out, produces the same number of splits as number of observations

  `:holdout` can accept also probabilites or ratios and can split to more than 2 subdatasets
  
  Additionally you can provide:

  * `:seed` - for random number generator
  * `:repeats` - repeat procedure `:repeats` times
  * `:partition-selector` - same as in `group-by` for stratified splitting to reflect dataset structure in splits.
  * `:split-names` names of subdatasets different than default, ie. `[:train :test :split-2 ...]`
  * `:split-col-name` - a column where name of split is stored, either `:train` or `:test` values (default: `:$split-name`)
  * `:split-id-col-name` - a column where id of the train/test pair is stored (default: `:$split-id`)
  * `:ratio` - specify a list of split ratios for `:holdout`. Need to have same size then `:split-names` (example: [0.2 0.2 0.6])

  Rows are shuffled before splitting.
  
  In case of grouped dataset each group is processed separately.

  See [more](https://www.mitpressjournals.org/doi/pdf/10.1162/EVCO_a_00069)"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/split ds-or-ctx))
  ([ds-or-ctx split-type]
   (scicloj.noj.v1.lifted-tc/split ds-or-ctx split-type))
  ([ds-or-ctx split-type options]
   (scicloj.noj.v1.lifted-tc/split ds-or-ctx split-type options)))


(defn split->seq
  "Returns split as a sequence of train/test datasets or map of sequences (grouped dataset)"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/split->seq ds-or-ctx))
  ([ds-or-ctx split-type]
   (scicloj.noj.v1.lifted-tc/split->seq ds-or-ctx split-type))
  ([ds-or-ctx split-type options]
   (scicloj.noj.v1.lifted-tc/split->seq ds-or-ctx split-type options)))


(defn tail
  "Last n rows (default 5)"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/tail ds-or-ctx))
  ([ds-or-ctx n]
   (scicloj.noj.v1.lifted-tc/tail ds-or-ctx n)))


(defn ungroup
  "Concat groups into dataset.

  When `add-group-as-column` or `add-group-id-as-column` is set to `true` or name(s), columns with group name(s) or group id is added to the result.

  Before joining the groups groups can be sorted by group name."
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/ungroup ds-or-ctx))
  ([ds-or-ctx options]
   (scicloj.noj.v1.lifted-tc/ungroup ds-or-ctx options)))


(defn union
  ([ds-or-ctx & args]
   (apply scicloj.noj.v1.lifted-tc/union ds-or-ctx args)))


(defn unique-by
  "Remove rows which contains the same data
  `column-selector` Select columns for uniqueness
  `strategy` There are 4 strategies defined to handle duplicates

    `:first` - select first row (default)
    `:last` - select last row
    `:random` - select random row
    any function - apply function to a columns which are subject of uniqueness"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/unique-by ds-or-ctx))
  ([ds-or-ctx columns-selector]
   (scicloj.noj.v1.lifted-tc/unique-by ds-or-ctx columns-selector))
  ([ds-or-ctx columns-selector options]
   (scicloj.noj.v1.lifted-tc/unique-by ds-or-ctx columns-selector options)))


(defn unmark-group
  "Remove grouping tag"
  ([ds-or-ctx]
   (scicloj.noj.v1.lifted-tc/unmark-group ds-or-ctx)))


(defn unroll
  "Unfolds sequences stored inside a column(s), turning it into multiple columns. Opposite of [[fold-by]].
  Add each of the provided columns to the set that defines the \"uniqe key\" of each row.
  Thus there will be a new row for each value inside the target column(s)' value sequence.
  If you want instead to split the content of the columns into a set of new _columns_, look at [[separate-column]].
  See https://scicloj.github.io/tablecloth/index.html#Unroll"
  ([ds-or-ctx columns-selector]
   (scicloj.noj.v1.lifted-tc/unroll ds-or-ctx columns-selector))
  ([ds-or-ctx columns-selector options]
   (scicloj.noj.v1.lifted-tc/unroll ds-or-ctx columns-selector options)))


(defn update-columns
  ([ds-or-ctx columns-map]
   (scicloj.noj.v1.lifted-tc/update-columns ds-or-ctx columns-map))
  ([ds-or-ctx columns-selector update-functions]
   (scicloj.noj.v1.lifted-tc/update-columns ds-or-ctx columns-selector update-functions)))


(defmacro without-grouping->
  ([ds-or-ctx & args]
   `(scicloj.noj.v1.lifted-tc/without-grouping-> ~ds-or-ctx ~@args)))


(defn write!
  "Write a dataset out to a file.  Supported forms are:

```clojure
(ds/write! test-ds \"test.csv\")
(ds/write! test-ds \"test.tsv\")
(ds/write! test-ds \"test.tsv.gz\")
(ds/write! test-ds \"test.nippy\")
(ds/write! test-ds out-stream)
```

Options:

  * `:max-chars-per-column` - csv,tsv specific, defaults to 65536 - values longer than this will
     cause an exception during serialization.
  * `:max-num-columns` - csv,tsv specific, defaults to 8192 - If the dataset has more than this number of
     columns an exception will be thrown during serialization.
  * `:quoted-columns` - csv specific - sequence of columns names that you would like to always have quoted.
  * `:file-type` - Manually specify the file type.  This is usually inferred from the filename but if you
     pass in an output stream then you will need to specify the file type.
  * `:headers?` - if csv headers are written, defaults to true."
  ([dataset output-path options]
   (scicloj.noj.v1.lifted-tc/write! dataset output-path options))
  ([dataset output-path]
   (scicloj.noj.v1.lifted-tc/write! dataset output-path)))


;; (defn write-csv!)



(defn write-nippy!
  ([ds-or-ctx filename]
   (scicloj.noj.v1.lifted-tc/write-nippy! ds-or-ctx filename)))


